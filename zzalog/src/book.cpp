#include "book.h"
#include "record.h"
#include "adi_reader.h"
#include "adi_writer.h"
#include "adx_reader.h"
#include "adx_writer.h"
#include "view.h"
#include "status.h"
#include "menu.h"
#include "tabbed_forms.h"
#include "spec_data.h"
#include "spec_tree.h"
#include "cty_data.h"
#include "utils.h"
#include "intl_widgets.h"
#include "eqsl_handler.h"
#include "lotw_handler.h"
#include "club_handler.h"
#include "qrz_handler.h"
#include "main_window.h"
#include "qso_manager.h"
#include "search.h"
#include "drawing.h"
#include "stn_data.h"

// C/C++ header files
#include <ctime>
// FLTK header files
#include <FL/Fl.H>
#include <FL/fl_ask.H>
#include <FL/Fl_Menu_Item.H>
#include <FL/Fl_Preferences.H>
#include <FL/Fl_Single_Window.H>
#include <FL/Fl_Button.H>




// Global data items
extern status* status_;
extern menu* menu_;
extern tabbed_forms* tabbed_forms_;
extern spec_data* spec_data_;
extern spec_tree* spec_tree_;
extern cty_data* cty_data_;
extern main_window* main_window_;
extern book* book_;
extern eqsl_handler* eqsl_handler_;
extern lotw_handler* lotw_handler_;
extern club_handler* club_handler_;
extern qrz_handler* qrz_handler_;
extern qso_manager* qso_manager_;
extern stn_data* stn_data_;
extern bool READ_ONLY;
extern void main_window_label(std::string text);
extern std::string PROGRAM_ID;
extern std::string PROGRAM_VERSION;
extern time_t session_start_;
extern bool AUTO_SAVE;
extern bool AUTO_UPLOAD;
extern bool RESUME_SESSION;
extern bool closing_;
extern std::string VENDOR;
extern std::string PROGRAM_ID;
extern Fl_Preferences::Root prefs_mode_;

const std::string default_header_ = "ADIF File generated by ZZALOG\n";

// Constructor - initialises some attributes
book::book(object_t type)
	: book_type_(type)
	, new_record_(false)
	, header_(nullptr)
	, inhibit_view_update_(false)
	, current_item_(0)
	, filename_("")
	, format_(FT_ADI)
	, criteria_(nullptr)
	, last_search_result_(0)
	, save_in_progress_(false)
	, delete_in_progress_(false)
	, old_record_(nullptr)
	, main_loading_(false)
	, save_level_(0)
	, adi_reader_(nullptr)
	, adx_reader_(nullptr)
	, adi_writer_(nullptr)
	, adx_writer_(nullptr)
	, upload_allowed_(true)
	, deleted_record_(false)
{
	used_bands_.clear();
	used_modes_.clear();
	used_submodes_.clear();
	used_rigs_.clear();
	used_antennas_.clear();
	used_callsigns_.clear();
	bands_.clear();
	modes_.clear();
	submodes_.clear();
	delete_contents(true);
}

// Destructor - iterative destroys contents
book::~book()
{
	// Just destroy the contents
	delete_contents(false);
}

// constructor to open a file and populate book
bool book::load_data(std::string filename)
{
	bool ok = false;
	if (book_type_ == OT_MAIN || book_type_ == OT_IMPORT) {
		// Only book types we should load
		// selection for the below choice
		enum choice_t : int {
			SAVE = 0,
			DONT_SAVE = 1,
			CANCEL = 2
		};
		choice_t choice = SAVE;
		if (is_dirty()) {
			// If the current data is modified, ask the user if it should be saved first
			fl_beep(FL_BEEP_QUESTION);
			choice = (choice_t)fl_choice("Current file is modified - do you want to save the changes?", "Save", "Don't Save", "Cancel");
			if (choice == SAVE) {
				store_data();
			}
		}
		if (choice != CANCEL) {
			// delete current contents (main only) - also stuff created by book
			if (book_type_ == OT_MAIN) {
				delete_contents(true);
			}

			// not called File->New
			if (filename.length() != 0) {
				// remember filename and tell ADIF spec database
				this->filename_ = filename;
				spec_data_->loaded_filename(filename_);
				// Update status bar
				char message[128];
				snprintf(message, sizeof(message), "LOG: Loading log-book %s", filename_.c_str());
				status_->misc_status(ST_NOTE, message);
				// Get the filetype suffix from the filename to know which reader to use
				std::string filetype;
				size_t last_period = filename.find_last_of('.');
				if (last_period != std::string::npos) {
					filetype = to_lower(filename.substr(last_period));
				}
				size_t last_slash = filename.find_last_of("/\\");
				if (last_slash != std::string::npos) {
					std::string file_directory = filename.substr(0, last_slash);
					Fl_Preferences settings(prefs_mode_, VENDOR.c_str(), PROGRAM_ID.c_str());
					Fl_Preferences datapath_settings(settings, "Datapath");
					datapath_settings.set("Log Directory", file_directory.c_str());
				}
				size_t start = last_slash == std::string::npos ? 0 : last_slash + 1;
				// Check for .adi or .adif format
				if (filetype == ".adi" || filetype == ".adif") {
					// Use ADI reader to read from an input stream connected to thefile
					adi_reader_ = new adi_reader;
					input_.open(filename.c_str(), fstream::in);
					// Load the book
					if (book_type_ == OT_MAIN) {
						main_loading_ = true;
					}
					if (!adi_reader_->load_book(this, input_)) {
						// Error while reading book
						char message[256];
						sprintf(message, "LOG: Failed to load %s", filename.c_str());
						status_->misc_status(closing_ ? ST_WARNING : ST_ERROR, message);
						if (book_type_ == OT_MAIN) {
							snprintf(message, sizeof(message), "%s [load failed]", filename.c_str());
							// Display message in main window title and update views that there's no or partial data
							main_window_label(message);
							selection(0, HT_NO_DATA);
							//Fl::wait();
						}
						delete adi_reader_;
						adi_reader_ = nullptr;
						ok = false;
					}
					else {
						char msg[128];
						std::snprintf(msg, sizeof(msg), "LOG: File %s loaded OK", filename.c_str());
						status_->misc_status(ST_OK, msg);
						if (book_type_ == OT_MAIN) {
							main_loading_ = false;
							// Display filename in title bar and update views there's new data
							if (READ_ONLY) {
								main_window_label(filename + " [read-only]");
							}
							else {
								main_window_label(filename);
								if (header_) header_->item("APP_ZZA_NUMRECORDS", to_string(size()));
							}
						}
						delete adi_reader_;
						adi_reader_ = nullptr;
						ok = true;
					}
					input_.close();
					if (format_ == FT_ADX) {
						// We have already loaded ADX data 
						status_->misc_status(ST_WARNING, "LOG: Loading .adi format when .adx already loaded, validation will be compromised");
						format_ = FT_MIXED;
					}
					else {
						// Set the format to ADI - this affects validation
						format_ = FT_ADI;
					}
				}
				// Check for .adx format
				else if (filetype == ".adx") {
					// Use ADX reader to load the data from the file through an input stream
					adx_reader_ = new adx_reader;
					// Opening in text mode appears to do some behind-the-scenes processing
					// when seeking backwards passed NL.
					input_.open(filename.c_str(), fstream::in | fstream::binary);
					main_loading_ = true;
					if (!input_.good() || !adx_reader_->load_book(this, input_)) {
						// Failed to complete the load
						char * message = new char[filename.length() + adx_reader_->information().length() + 100];
						sprintf(message, "LOG: Failed to open %s. Error messages = %s", filename.c_str(), adx_reader_->information().c_str());
						status_->misc_status(closing_ ? ST_WARNING : ST_ERROR, message);
						delete[] message;
						clear();
						if (book_type_ == OT_MAIN) {
							// Update title bar and tell views
							main_window_label("[load failed]");
							selection(0, HT_NO_DATA);
							//Fl::wait();
						}
						delete adx_reader_;
						adx_reader_ = nullptr;
						ok = false;
					}
					else {
						if (book_type_ == OT_MAIN) {
							// Update title bar and tell views
							main_loading_ = false;
							if (READ_ONLY) {
								main_window_label(filename + " [read-only]");
							}
							else {
								main_window_label(filename);
							}
						}
						delete adx_reader_;
						adx_reader_ = nullptr;
						ok = true;
					}
					input_.close();
					if (format_ == FT_ADI) {
						// Mixed source
						status_->misc_status(ST_WARNING, "LOG: Loading .adi format when .adx already loaded, validation will be compromised");
						format_ = FT_MIXED;
					}
					else {
						// Remeber ADX for validation
						format_ = FT_ADX;
					}

				}
				// neither .adi nor .adx 
				else {
					char* message = new char[filename.length() + 100];
					sprintf(message, "LOG: Unknown file format. '%s' ignored", filename.c_str());
					status_->misc_status(ST_ERROR, message);
					delete[] message;
					ok = false;
				}
				if (ok) {
					char* message = new char[filename.length() + 100];
					size_t num_records = size();
					if (header()) num_records++;
					sprintf(message, "LOG: %zu records loaded", num_records);
					status_->misc_status(ST_OK, message);
					delete[] message;
				}
				set_session_start();

				current_item_ = size() - 1;
				tabbed_forms_->update_views(nullptr, HT_ALL, current_item_);
				// TODO: Review how to update spec_data that is dependent on read in values 
				// do the following for now
				tabbed_forms_->update_views(nullptr, HT_FORMAT, current_item_);
			}
			else { // filename.length() == 0 (File->New)
				main_window_label("[No file loaded]");
				// Create a header record
				record* header = new record();
				this->header(header);
				header_->header(default_header_);
				// tell views there is no data to display
				selection(0, HT_NO_DATA);
				Fl::redraw();
				ok = true;
			}
		}
		else { // choice == CANCEL
			ok = false;
		}
	}
	else {
		// Cannot load other types.
		status_->misc_status(ST_ERROR, "LOG: An extract or export type of book cannot be constructed by reading a file");
		ok = false;
	}
	return ok;
}

// Store data - only if modified or force is true. If fields is defined only output specified fields
bool book::store_data(std::string filename, bool force, field_list* fields) {
	bool ok = false;
	bool changed_file = false;
	if (save_in_progress_) {
		// Race hazard - can instigate a second store before finished this one
		status_->misc_status(ST_WARNING, "LOG: Ignoring request to store log as currently doing so");
	}
	else {
		if (book_type_ == OT_MAIN || book_type_ == OT_EXTRACT) {
			// can only write out main log or extracted records
			save_in_progress_ = true;
			// Check we are not in the middle of modifying a record 
			if (new_record()) {
				// Clear this first to avoid iteration through this question
				fl_beep(FL_BEEP_QUESTION);
				switch (fl_choice("You are currently adding a record? Save or Quit?", "Save?", "Quit?", nullptr)) {
				case 0:
					break;
				case 1:
					// Quit - delete any new record
					delete_record(new_record());
					break;
				}
				new_record_ = false;
			}

			// First parse and validate if necessary
			if (is_dirty() == true || force) {
				// Only write out if modified or force is std::set
				if (!header_) {
					// No header then create one.
					header_ = new record;
					header_->header(" ");
				} else {
					// Add a single space comment if there is not an existing comment.
					if (header_->header().length() == 0) {
						header_->header(" ");
					}
				}
				// Update header specific items
				header_->item("PROGRAMID", PROGRAM_ID);
				header_->item("PROGRAMVERSION", PROGRAM_VERSION);
				header_->item("ADIF_VER", spec_data_->adif_version());
				header_->item("APP_ZZA_NUMRECORDS", to_string(size()));

				// use supplied filename (for Save As) or remembered filename (for Save)
				if (filename != "") {
					filename_ = filename;
					changed_file = true;
				}
				// Update status bar
				char * message = new char[filename_.length() + 20];
				sprintf(message, "LOG: %s", filename_.c_str());
				status_->misc_status(ST_NOTE, message);
				delete[] message;
				// Rename the last 8 saves
				for (char c = '8'; c > '0'; c--) {
					// Rename will fail if file does not exist, so no need to test file exists
					std::string oldfile = filename_ + c;
					char c2 = c + 1;
					std::string newfile = filename_ + c2;
					fl_rename(oldfile.c_str(), newfile.c_str());
				}
				fl_rename(filename_.c_str(), (filename_ + '1').c_str());

				// Output stream
				std::ofstream file;
				// Get file type suffix
				std::string filetype = "";
				size_t last_period = filename_.find_last_of('.');
				if (last_period != std::string::npos) {
					// Get file type
					filetype = to_lower(filename_.substr(last_period));
				}
				size_t last_slash = filename.find_last_of("/\\");
				if (last_slash != std::string::npos) {
					std::string file_directory = filename.substr(0, last_slash);
					Fl_Preferences settings(prefs_mode_, VENDOR.c_str(), PROGRAM_ID.c_str());
					Fl_Preferences datapath_settings(settings, "Datapath");
					datapath_settings.set("Log Directory", file_directory.c_str());
				}
				// Check for .adi format
				if (filetype == ".adi" || filetype == ".adif") {
					// Connect file to output stream and get ADI writer to write it
					if (book_type_ == OT_MAIN) {
					}
					file.open(filename_.c_str(), fstream::out);
					adi_writer_ = new adi_writer;
					if (adi_writer_->store_book(this, file, book_type_ == OT_MAIN ? true : false, fields) != LR_GOOD) {
						// Store failed
						char* message = new char[filename_.length() + 100];
						sprintf(message, "LOG: Failed to open %s", filename_.c_str());
						delete[] message;
						file.close();
						ok = false;
					}
					else {
						ok = true;
					}
					delete adi_writer_;
					adi_writer_ = nullptr;
				}
				// check for .adx format
				else if (filetype == ".adx") {
					// Connect file to output stream and store data
					if (book_type_ == OT_MAIN) {
					}
					file.open(filename_.c_str(), fstream::out);
					adx_writer_ = new adx_writer;
					if (!adx_writer_->store_book(this, file, book_type_ == OT_MAIN ? true: false)) {
						// Store failed
						char * message = new char[filename_.length() + 100];
						sprintf(message, "LOG: Failed to open %s", filename_.c_str());
						status_->misc_status(ST_ERROR, message);
						delete[] message;
						file.close();
						ok = false;
					}
					else {
						ok = true;
					}
					delete adx_writer_;
					adx_writer_ = nullptr;
				}
				else {
					// Unknown file type
					char * message = new char[filename_.length() + 100];
					sprintf(message, "LOG: Unknown file format. %s ignored", filename_.c_str());
					status_->misc_status(ST_WARNING, message);
					delete[] message;
					ok = false;
				}
				if (ok) {
					deleted_record_ = false;
					char* message = new char[filename_.length() + 100];
					size_t num_records = size();
					if (header()) num_records++;
					sprintf(message, "LOG: %zu records written to %s", num_records, filename_.c_str());
					status_->misc_status(ST_OK, message);
					delete[] message;
				}
				if (ok && book_type_ == OT_MAIN) {
					// File was closed in the fail paths
					file.close();
					// Update file name on window label
					if (changed_file) main_window_label(filename_);
				}
			}
			else {
				ok = false;
			}
			save_in_progress_ = false;
		}
		else {
			// Cannot write an imported file
			char message[256];
			snprintf(message, 256, "LOG: Attempting to write %s - this book is not writeable", (filename == "" ? filename_.c_str() : filename.c_str()));
			status_->misc_status(ST_ERROR, message);
			ok = false;
		}
	}
	// Update menu item activeness - redraw log tables to remove modified hue
	tabbed_forms_->update_views(nullptr, HT_FORMAT, 0);
	menu_->update_items();
	return ok;
}

// Get the current selected record - return NULL if current_record beyond the size of array
record* book::get_record() {
	if (current_item_ < size()) {
		return at(current_item_);
	}
	else {
		return NULL;
	}
}

// Get the numbered record and optionally select it (quietly)
record* book::get_record(item_num_t num_item, bool set_selected/* = true*/) {
	if (num_item < size()) {
		if (set_selected) {
			// Set the selected record
			current_item_ = num_item;
		}
		return at(num_item);
	}
	else {
		// item number beyond the size of the book
		return NULL;
	}
}

// Get the last recod in book
record* book::get_latest() {
	return get_record(size() - 1, false);
}

// Copy the current record
void book::remember_record() {
	// Assume we are changing selection so if the record is unmodified save its contents
	if (!is_dirty_record(get_record()) && !new_record() && book_type_ == OT_MAIN) {
		delete old_record_;
		old_record_ = new record(*get_record(current_item_, false));
	}
}

// Change the selected record (& update any necessary controls
item_num_t book::selection(item_num_t num_item, hint_t hint /* = HT_SELECTED */, view* requester /* = nullptr */, item_num_t num_other /*= 0*/) {
	if (save_in_progress_) {
		status_->misc_status(ST_WARNING, "LOG: Currently storing the book, cannot change selection");
		return current_item_;
	}
	else {
		item_num_t previous = current_item_;
		// Special case - -1 indicates no change to the selection
		if ((signed)num_item != -1 && size()) {
			current_item_ = num_item;
			remember_record();
		}
		else {
		}
		record* this_record = get_record(current_item_, false);
		qso_num_t record_num = record_number(current_item_);
		// update turned off during certain activities
		switch (hint) {
		case HT_IMPORT_QUERY:
		case HT_IMPORT_QUERYNEW:
		case HT_DUPE_QUERY:
			// Query against first record in import_data or identified record
			tabbed_forms_->update_views(requester, hint, record_num, record_number(num_other));
			break;
		case HT_CHANGED:
		case HT_MINOR_CHANGE:
			if (!inhibit_view_update_) {
				// Update to this record
				tabbed_forms_->update_views(requester, hint, record_num);
			}
			break;
		case HT_INSERTED:
		case HT_INSERTED_NODXA:
		case HT_DELETED:
			if (!inhibit_view_update_) {
				// Update to this record
				tabbed_forms_->update_views(requester, hint, record_num);
			}
			break;
		case HT_START_CHANGED:
			// The QSO start date has been changed. Re-order the book and tell everyone
			this_record = get_record(current_item_, false);
			erase(begin() + current_item_);
			record_num = insert_record(this_record);
			tabbed_forms_->update_views(requester, HT_ALL, record_num);
			break;
		default:
			if (!inhibit_view_update_) {
				tabbed_forms_->update_views(requester, hint, record_num);
			}
			break;
		}
		if (current_item_ != previous && 
			!READ_ONLY && 
			save_level_ == 0 && 
			is_dirty() && 
			!save_in_progress_ ) {
			if (AUTO_SAVE) store_data();
		}
		// Update menu item activeness
		menu_->update_items();
		return record_num;
	}
}

// Get the current selected item
item_num_t book::selection() {
	return current_item_;
}

// Insert a record in its chronological position 
qso_num_t book::insert_record(record* record) {
	// Always mark a new record dirty
	add_dirty_record(record, "Inserting record");
	// Get the offset where to add the record and insert it into the array
	item_num_t pos_record = get_insert_point(record);
	insert_record_at(pos_record, record);
	return pos_record;
}

// Append a record at the end of the book
item_num_t book::append_record(record* record) {
	// Always mark a new record dirty
	add_dirty_record(record, "Appending record");
	item_num_t pos_record = size();
	insert_record_at(pos_record, record);
	return pos_record;
}

// add a header record
void book::header(record* header) {
	delete header_;
	header_ = header;
}

// return the header record
record* book::header() {
	return header_;
}

// Delete all records and tidy up
void book::delete_contents(bool new_book) {
	// Delete the individual records
	for (auto it = begin(); it != end(); it++) {
		delete *it;
	}
	// Clear the array
	clear();
	// Set it unmodified
	dirty_qsos_.clear();
	filename_ = "";
	format_ = FT_NONE;
	delete header_;
	header_ = nullptr;
	// Delate all informationed maintained about data
	used_modes_.clear();
	used_bands_.clear();
	used_submodes_.clear();
	used_rigs_.clear();
	used_antennas_.clear();
	used_callsigns_.clear();
	bands_.clear();
	modes_.clear();
	submodes_.clear();
	if (new_book && book_type_ == OT_MAIN) {
		// Delete all non-ADIF defined fields 
		spec_data_->delete_user_data();
		spec_data_->delete_appdefs();
		spec_data_->delete_userdefs();
		// Restore this app's app-defined fields
		spec_data_->add_my_appdefs();

	}
	if (book_type_ == OT_MAIN) {
		// Update status to empty
		main_loading_ = false;
	}
}

// Return count of records
item_num_t book::get_count() {
	return size();
}

// returns the position at which to chronologically insert a record
item_num_t book::get_insert_point(record* record) {
	// Find where to insert the record
	// operator> overloaded to compare Record date and start time
	// Check at tail as new record likely to be a more recent one.
	item_num_t upper_bound = size() == 0 ? 0 : size() - 1;
	item_num_t lower_bound = 0;
	item_num_t next_bound;

	// if the book is empty add to the beginning 
	if (size() == 0) {
		return 0;
	}
	// if the record has not been corrected - then the last in the bbook
	else if (record == nullptr) {
		return size();
	}
	// if the record is later than the last in the book.
	else if (*record > *(at(upper_bound))) {
		return size();
	}
	else {
		// Check at beginning - is it earlier?
		if (!(*record > *(at(0)))) {
			return 0;
		}
		else {
			// Binary slice the array until found
			// Keep comparing the record between upper bound and lower bound
			// until the gap between them is nil. then put it there.
			while (upper_bound - 1 != lower_bound) {
				// Compare with the half-way point 
				next_bound = (lower_bound + upper_bound) / 2;
				if (*record > *(at(next_bound))) {
					// It's between half-way and upper-bound, move lower-bound to half-way
					lower_bound = next_bound;
				}
				else {
					// It's between half-way and lower-bound, move upper-bound to half-way
					upper_bound = next_bound;
				}
			}
			return upper_bound;
		}
	}
}

// insert the record at specific position
void book::insert_record_at(item_num_t pos_record, record* record) {
	// get the iterator to the insert position
	insert(begin() + pos_record, record);
	if (!loading()) {
		add_dirty_record(record, "Inserting record");
	}
	if (book_type_ == OT_MAIN) {
		// Update summary lookups
		if (record->item("QSO_COMPLETE") == "" || record->item("QSO_COMPLETE") == "Y") {
			add_use_data(record);
		}
	}
}

// Navigate the log - i.e. go to specific position
void book::navigate(navigate_t target) {
	switch (target) {
	case NV_FIRST:
		// Select first record
		selection(0);
		break;
	case NV_PREV:
		// Select previous record
		if (selection() > 0) {
			selection(selection() - 1);
		}
		break;
	case NV_LAST:
		// Select last record
		selection(size() - 1);
		break;
	case NV_NEXT:
		// select next record 
		if (selection() < size() - 1) {
			selection(selection() + 1);
		}
		break;
	}
}

// Go to the date specified
void book::go_date(std::string date) {
	// std::set the bounds of the search - binary split search
	item_num_t u_bound = size() - 1;
	item_num_t l_bound = 0;
	// Continue until a gap of only 1 between upper and lower bounds of the search
	while (u_bound - l_bound > 1) {
		// Compare std::string form of dates
		std::string u_date = at(u_bound)->item("QSO_DATE");
		std::string l_date = at(l_bound)->item("QSO_DATE");
		if (u_date < date) {
			// Date later than last record considered - force loop to end
			l_bound = u_bound;
		}
		else if (l_date > date) {
			// Date earlier than first record considered - force loop to end
			u_bound = l_bound;
		}
		else {
			// Now implement binary search - repeatedly halving search range 
			item_num_t mid_pos = (l_bound + u_bound) / 2;
			std::string m_date = at(mid_pos)->item("QSO_DATE");
			if (m_date > date) {
				// Date in earlier half
				u_bound = mid_pos;
			}
			else {
				// Daate in later half
				l_bound = mid_pos;
			}
		}
	}
	// Selected the earlier of the two records
	selection(l_bound);
}

// return the filename
std::string book::filename(bool full /*=true*/) {
	if (full) {
		// Returns full filename
		return filename_;
	}
	else {
		// Return the filename after the last slash
		size_t pos = filename_.find_last_of("/\\");
		return filename_.substr(pos + 1);
	}
}

// delete the selected record - force std::set if not created the record through book API
void book::delete_record(bool force) {
	// Either entering a new record or user allows to delete a saved record
	if (force || new_record_) {
		// We cannot delete two records at once as it confuses the value of current_item_
		if (delete_in_progress_) {
			status_->misc_status(ST_WARNING, "LOG: Delete record inhibited");
		}
		else {
			// Update status bar and menu items
			char text[128];
			sprintf(text, "LOG: Deleting record %s %s %s",
				get_record()->item("QSO_DATE").c_str(),
				get_record()->item("TIME_ON").c_str(),
				get_record()->item("CALL").c_str());
			status_->misc_status(ST_NOTE, text);
			delete_in_progress_ = true;
			menu_->update_items();
			// Remove the current record from both the book_ and the extract_data_
			record* del_record = get_record();
			delete_dirty_record(del_record);
			if (book_type_ == OT_EXTRACT) {
				book_->erase(book_->begin() + record_number(current_item_));
			} 
			erase(begin() + current_item_);
			// if current record no longer exists decrement it (exept if already first record)
			if (current_item_ == size() && current_item_ > 0) {
				current_item_--;
			}
			// Tell the views a record has been deleted and to redraw from the current selection
			selection(current_item_, HT_DELETED);
			new_record_ = false;
			deleted_record_ = true;
			// After selection has done its all can allow another delete
			delete_in_progress_ = false;
			menu_->update_items();
		}
	}
	else if (is_dirty_record(get_record())) {
		// Update status bar and menu items
		char text[128];
		sprintf(text, "LOG: Canceling edit record %s %s %s",
			get_record()->item("QSO_DATE").c_str(),
			get_record()->item("TIME_ON").c_str(),
			get_record()->item("CALL").c_str());
		status_->misc_status(ST_NOTE, text);
		// Cancel record edit.
		if (old_record_) {
			*get_record() = *old_record_;
			delete old_record_;
			old_record_ = nullptr;
		}
		// Because we have not updated other views yet, we only regard this as a minor change
		selection(-1, HT_MINOR_CHANGE);
		menu_->update_items();
	}
	if (AUTO_SAVE && save_level_ == 0 && !READ_ONLY && is_dirty()) {
		store_data();
	}

}

// Move the record to its correct chronological position
item_num_t book::correct_record_position(item_num_t current_pos) {
	// First delete the old position so it doesn't confuse GetOffset
	// Save the record first
	record* this_record = get_record(current_pos, false);
	// remove record at existing position
	erase(begin() + current_pos);
	// now insert it in the correct position and other bookkeeping
	return insert_record(this_record);
}

// Returns whether a record matches the search criteria
bool book::match_record(record* record) {
	// Two level matching
	bool match = basic_match(record) && refine_match(record);
	return match;
}

// Returns whether a record matches the basic search condition.
bool book::basic_match(record* record) {
	// See if record matches criterion
	switch (criteria_->condition) {
	case XC_UNFILTERED:
		// match all records
		return true;
	case XC_CALL:
		// match by callsign
		return match_string(criteria_->pattern, criteria_->comparator, record->item("CALL"));
		break;
	case XC_CONT:
		// match by continent
		return match_string(criteria_->pattern, criteria_->comparator, record->item("CONT"));
		break;
	case XC_CQZ:
		// match by CQ Zone number
		return match_int(criteria_->pattern, criteria_->comparator, record->item("CQZ"));
		break;
	case XC_DXCC:
	{
		// See if it is a valid nickname
		int dxcc = cty_data_->entity(criteria_->pattern);
		if (criteria_->pattern.length() == 0) {
			// Null std::string - check records with no value
			return match_string(criteria_->pattern, criteria_->comparator, record->item("DXCC"));
		}
		else if (dxcc == -1 || criteria_->comparator == XP_LT || criteria_->comparator == XP_LE ||
			criteria_->comparator == XP_GE || criteria_->comparator == XP_GT) {
			// Not a nickname so match against the raw value
			return match_int(criteria_->pattern, criteria_->comparator, record->item("DXCC"));
		}
		else {
			// Treat as a nickname - match against the dxcc value for the nickname
			return match_string(to_string(dxcc), criteria_->comparator, record->item("DXCC"));
		}
	}
	case XC_FIELD:
		// match by a specified field
		return match_string(criteria_->pattern, criteria_->comparator, record->item(criteria_->field_name));
		break;
	case XC_ITUZ:
		// match by ITU zone number
		return match_int(criteria_->pattern, criteria_->comparator, record->item("ITUZ"));
		break;
	case XC_SQ2:
		// match by first two characters of locator
		// condition too short
		if (criteria_->pattern.length() < 2) break;
		// gridsquare in record too short
		if (criteria_->comparator != XP_REGEX && record->item("GRIDSQUARE").length() < 2) break;
		return match_string(criteria_->pattern.substr(0, 2), criteria_->comparator, record->item("GRIDSQUARE").substr(0, 2));
		break;
	case XC_SQ4:
		// match by first 4 charactes of locator
		if (criteria_->pattern.length() < 4) break;
		if (criteria_->comparator != XP_REGEX && record->item("GRIDSQUARE").length() < 4) break;
		return match_string(criteria_->pattern.substr(0, 4), criteria_->comparator, record->item("GRIDSQUARE").substr(0, 4));
		break;
	default:
		return false;
	}
	// we should never get here
	return false;
}

// refine match - by date, band, mode or confirmation
bool book::refine_match(record* record) {
	// now refine by dates
	if (criteria_->by_dates) {
		std::string record_date = record->item("QSO_DATE");
		// confirm the match is between specified dates - inclusive
		if (record_date < criteria_->from_date || record_date > criteria_->to_date) {
			return false;
		}
	}
	// now refine by band - confirm if the record is on that band
	if (criteria_->band != "Any" && criteria_->band != record->item("BAND")) {
		return false;
	}
	// Refine by mode - confirm if the record has that mode 
	if (criteria_->mode != "Any" && criteria_->mode != record->item("MODE") &&
		criteria_->mode != record->item("SUBMODE")) {
		return false;
	}
	// Refine by call - confirm if the record matches my_call (STATION_CALLSIGN)
	if (criteria_->my_call != "Any" && criteria_->my_call != record->item("STATION_CALLSIGN")) {
		return false;
	}
	// Refine by eQSL card - confirm if eQSL confirmation
	if (criteria_->confirmed_eqsl && record->item("EQSL_QSL_RCVD") != "Y") {
		return false;
	}
	// Refine by LotW - confirm if LotW confirmation
	if (criteria_->confirmed_eqsl && record->item("LOTW_QSL_RCVD") != "Y") {
		return false;
	}
	// Refine by card - confirm if card confirmation
	if (criteria_->confirmed_card && record->item("QSL_RCVD") != "Y") {
		return false;
	}
	return true;
}

// std::string item matches taking whether to use regex or not.
bool book::match_string(std::string test, int comparator, std::string value) {
	switch ((search_comp_t)comparator) {
	case XP_REGEX: {
		std::basic_regex<char> regex(to_upper(test));
		return regex_match(to_upper(value), regex);
	}
	case XP_NE:
		return (to_upper(value) != to_upper(test));
	case XP_LT:
		return (to_upper(value) < to_upper(test));
	case XP_LE:
		return (to_upper(value) <= to_upper(test));
	case XP_EQ:
		return (to_upper(value) == to_upper(test));
	case XP_GE:
		return (to_upper(value) >= to_upper(test));
	case XP_GT:
		return (to_upper(value) > to_upper(test));
	default:
		return false;
	}
}

// integer item matching - ignores things like leading zeros and trailing non numeric characters
bool book::match_int(std::string test, int comparator, std::string value) {
	try {
		return match_int(std::stoi(test), comparator, std::stoi(value));
	}
	catch (const invalid_argument&) {
		return false;
	}
}

// integer item matching - integer vs integer
bool book::match_int(int test, int comparator, int value) {
	switch ((search_comp_t)comparator) {
	case XP_NE:
		return (value != test);
	case XP_LT:
		return (value < test);
	case XP_LE:
		return (value <= test);
	case XP_EQ:
		return (value == test);
	case XP_GE:
		return (value >= test);
	case XP_GT:
		return (value > test);
	default:
		return (test == value);
	}
}

// Returns the position of the next record that matches search criterion
item_num_t book::search(search_criteria_t* criteria, bool reset_search) {
	// Save the criteria
	criteria_ = criteria;
	item_num_t ix;
	if (reset_search) {
		ix = 0;
	}
	else {
		ix = last_search_result_ + 1;
	}
	for (; ix < size() && !match_record(get_record(ix, false)); ix++) {}
	if (ix < size()) {
		last_search_result_ = ix;
	}
	else {
		last_search_result_ = -1;
	}
	return last_search_result_;
}

// returns the current usage of the book
object_t book::book_type() { return book_type_; }

// Sets the book type
void book::book_type(object_t value) {
	book_type_ = value;
}

// Add the band and mode to the lists of used bands and modes if not already there
void book::add_use_data(record* use_record) {
	// Do not look at SWL records
	if (use_record->item("SWL") == "") {
		std::string band = use_record->item("BAND");
		std::string dxcc = use_record->item("DXCC");
		std::string call = use_record->item("STATION_CALLSIGN");
		std::string grid = use_record->item("GRIDSQUARE");
		if (grid.length() < 4) grid = "";
		else grid = grid.substr(0, 4);
		std::string cqz = use_record->item("CQZ");
		std::string ituz = use_record->item("ITUZ");
		std::string cont = use_record->item("CONT");

		if (band == "") {
			// Get the band from the frequency 
			double freq = 0.0;
			use_record->item("FREQ", freq);
			band = spec_data_->band_for_freq(freq);
			use_record->item("BAND", band);
		}
		if (band.length()) {
			used_bands_.insert(band);
			bands_[call][WK_DXCC][dxcc].insert(band);
			bands_[call][WK_GRID4][grid].insert(band);
			bands_[call][WK_CQZ][cqz].insert(band);
			bands_[call][WK_ITUZ][ituz].insert(band);
			bands_[call][WK_CONT][cont].insert(band);
			bands_[""][WK_DXCC][dxcc].insert(band);
			bands_[""][WK_GRID4][grid].insert(band);
			bands_[""][WK_CQZ][cqz].insert(band);
			bands_[""][WK_ITUZ][ituz].insert(band);
			bands_[""][WK_CONT][cont].insert(band);
		}
		std::string mode = use_record->item("MODE");
		if (mode.length()) {
			used_modes_.insert(mode);
			modes_[call][WK_DXCC][dxcc].insert(mode);
			modes_[call][WK_GRID4][grid].insert(mode);
			modes_[call][WK_CQZ][cqz].insert(mode);
			modes_[call][WK_ITUZ][ituz].insert(mode);
			modes_[call][WK_CONT][cont].insert(mode);
			modes_[""][WK_DXCC][dxcc].insert(mode);
			modes_[""][WK_GRID4][grid].insert(mode);
			modes_[""][WK_CQZ][cqz].insert(mode);
			modes_[""][WK_ITUZ][ituz].insert(mode);
			modes_[""][WK_CONT][cont].insert(mode);
		}
		std::string submode = use_record->item("SUBMODE");
		if (!submode.length()) {
			submode = use_record->item("MODE");
		}
		if (submode.length()) {
			used_submodes_.insert(submode);
			submodes_[call][WK_DXCC][dxcc].insert(submode);
			submodes_[call][WK_GRID4][grid].insert(submode);
			submodes_[call][WK_CQZ][cqz].insert(submode);
			submodes_[call][WK_ITUZ][ituz].insert(submode);
			submodes_[call][WK_CONT][cont].insert(submode);
			submodes_[""][WK_DXCC][dxcc].insert(submode);
			submodes_[""][WK_GRID4][grid].insert(submode);
			submodes_[""][WK_CQZ][cqz].insert(submode);
			submodes_[""][WK_ITUZ][ituz].insert(submode);
			submodes_[""][WK_CONT][cont].insert(submode);
		}
		std::string rig = use_record->item("MY_RIG");
		bool update_spec = false;
		if (rig.length()) {
			if (used_rigs_.find(rig) == used_rigs_.end()) {
				used_rigs_.insert(rig);
				spec_data_->add_user_enum("MY_RIG", rig);
				update_spec = true;
			}
		}
		std::string antenna = use_record->item("MY_ANTENNA");
		if (antenna.length()) {
			if (used_antennas_.find(antenna) == used_antennas_.end()) {
				used_antennas_.insert(antenna);
				spec_data_->add_user_enum("MY_ANTENNA", antenna);
				update_spec = true;
			}
		}
		std::string callsign = use_record->item("STATION_CALLSIGN");
		if (callsign.length()) {
			if (used_callsigns_.find(callsign) == used_callsigns_.end()) {
				used_callsigns_.insert(callsign);
				spec_data_->add_user_enum("STATION_CALLSIGN", callsign);
				update_spec = true;
			}
		}
		deprecate_macros(use_record);

		// A log-defined enum or a macro has changed
		if (update_spec && !main_loading_) {
			tabbed_forms_->update_views(nullptr, HT_FORMAT, size() - 1);
		}
	}
}

void book::deprecate_macros(record* use_record) {
	char msg[128];
	// If APP_ZZA_QTH is present - take its values and send to stn_data
	std::string qth_id = use_record->item("APP_ZZA_QTH");
	if (qth_id.length()) {
		// Copy items from ADIF record to STN data
		for (auto it : QTH_ADIF_MAP) {
			std::string value = use_record->item(it.second);
			if (value.length()) {
				if (stn_data_->add_qth_item(qth_id, it.first, value)) {
					snprintf(msg, sizeof(msg), "LOG: Added QTH %s: item %s=%s",
						qth_id.c_str(), it.second.c_str(), value.c_str());
					status_->misc_status(ST_NOTE, msg);
				}
			}
		}
		// And copy them and previous items back
		const qth_info_t* stn_items = stn_data_->get_qth(qth_id);
		if (stn_items == nullptr) {
			snprintf(msg, sizeof(msg), "LOG: No data has been added for QTH %s", qth_id.c_str());
		}
		else {
			for (auto it : stn_items->data) {
				std::string item = QTH_ADIF_MAP.at(it.first);
				use_record->item(item, it.second);

			}
		}
		use_record->item("APP_ZZA_QTH", std::string(""));
	}
	// If APP_ZZA_OP is present - take its values and send to stn_data
	std::string oper_id = use_record->item("APP_ZZA_OP");
	if (oper_id.length()) {
		// Copy items from ADIF record to STN data
		for (auto it : OPER_ADIF_MAP) {
			std::string value = use_record->item(it.second);
			if (value.length()) {
				if (stn_data_->add_oper_item(oper_id, it.first, value)) {
					snprintf(msg, sizeof(msg), "LOG: Added Operator %s: item %s=%s",
						oper_id.c_str(), it.second.c_str(), value.c_str());
					status_->misc_status(ST_NOTE, msg);
				}
			}
		}
		// And copy them and previous items back
		const oper_info_t* stn_items = stn_data_->get_oper(oper_id);
		if (stn_items == nullptr) {
			snprintf(msg, sizeof(msg), "LOG: No data has been added for Operator %s", qth_id.c_str());
		}
		else {
			for (auto it : stn_items->data) {
				std::string item = OPER_ADIF_MAP.at(it.first);
				use_record->item(item, it.second);
			}
		}
		use_record->item("APP_ZZA_OP", std::string(""));
	}
	// Not strictly a macro, but part of the operation parameters
	std::string call = use_record->item("STATION_CALLSIGN");
	if (call.length()) {
		if (stn_data_->add_call(call)) {
			snprintf(msg, sizeof(msg), "LOG: Added Callsign %s", call.c_str());
		}
	}
}

// get used bands
band_set* book::used_bands() {
	return &used_bands_;
}

band_set* book::used_bands(worked_t category = WK_ANY, int32_t entity = 0, std::string call = "") {
	return used_bands(category, to_string(entity), call);
}

band_set* book::used_bands(worked_t category = WK_ANY, std::string entity = "", std::string call = "") {
	band_set* result = nullptr;
	if (category == WK_ANY) return &used_bands_;
	else if (bands_.find(call) == bands_.end());
	else if (bands_.at(call).find(category) == bands_.at(call).end());
	else if (bands_.at(call).at(category).find(entity) == bands_.at(call).at(category).end() || entity == "-1");
	else return &bands_.at(call).at(category).at(entity);
	return result;
}

// get used modes
std::set<std::string>* book::used_modes() {
	return &used_modes_;
}

std::set<std::string>* book::used_modes(worked_t category = WK_ANY, int32_t entity = 0, std::string call = "") {
	return used_modes(category, to_string(entity), call);
}

std::set<std::string>* book::used_modes(worked_t category = WK_ANY, std::string entity = "", std::string call = "") {
	std::set<std::string>* result = nullptr;
	if (category == WK_ANY) return &used_modes_;
	else if (modes_.find(call) == modes_.end());
	else if (modes_.at(call).find(category) == modes_.at(call).end());
	else if (modes_.at(call).at(category).find(entity) == modes_.at(call).at(category).end() || entity == "-1");
	else return &modes_.at(call).at(category).at(entity);
	return result;
}

// get used submodes
std::set<std::string>* book::used_submodes() {
	return &used_submodes_;
}

std::set<std::string>* book::used_submodes(worked_t category = WK_ANY, int32_t entity = 0, std::string call = "") {
	return used_submodes(category, to_string(entity), call);
}

std::set<std::string>* book::used_submodes(worked_t category = WK_ANY, std::string entity = "", std::string call = "") {
	std::set<std::string>* result = nullptr;
	if (category == WK_ANY) return &used_submodes_;
	else if (submodes_.find(call) == submodes_.end());
	else if (submodes_.at(call).find(category) == submodes_.at(call).end());
	else if (submodes_.at(call).at(category).find(entity) == submodes_.at(call).at(category).end() || entity == "-1");
	else return &submodes_.at(call).at(category).at(entity);
	return result;
}

// Returns true if a new record being entered
bool book::new_record() { return new_record_; }

// Set new record flag
void book::new_record(bool value) {
	new_record_ = value;
}

// Set save_enabled_ (and save if modified)
void book::enable_save(bool enable, const char* reason) {
	if (enable) {
		if (save_level_) save_level_--;
	}
	else {
		save_level_++;
	}
	char msg[128];
	snprintf(msg, sizeof(msg), "LOG: Setting save enable level %d - %s", save_level_, reason);
	status_->misc_status(ST_LOG, msg);
	if (AUTO_SAVE && save_level_ == 0 && !READ_ONLY && is_dirty()) {
		store_data();
	}
}

// Return whether save is enabled
bool book::enable_save() {
	return save_level_ == 0;
}

// Check duplicates - restart std::set after a query to confirm it's a duplicate
void book::check_dupes(bool restart) {
	if (!restart) {
		test_item_ = 0;
		// Only check N - 1 entries against the next entry
		status_->misc_status(ST_NOTE, "LOG: Duplicate checking started");
		status_->progress(size() - 1, book_type(), "Checking log for duplicates", "duplicates");
		inhibit_view_update_ = true;
		number_dupes_kept_ = 0;
		number_dupes_removed_ = 0;
		enable_save(false, "Checking dupes");
	}
	bool possible_dupe = false;
	for (; test_item_ < size() - 1 && !possible_dupe;) {
		// Get adjacent records
		record* record_1 = get_record(test_item_, true);
		record* record_2;
		match_result_t match = MT_OVERLAP;
		// MT_OVERLAP indicates it overlaps but not same call.
		for (dupe_item_ = test_item_ + 1; 
			dupe_item_ < size() && match == MT_OVERLAP;
		    ) {
			record_2 = get_record(dupe_item_, false);
			match = record_1->match_records(record_2);
			if (match == MT_OVERLAP) dupe_item_++;
		}
		switch (match) {
		case MT_NOMATCH:
		case MT_SWL_NOMATCH:
		case MT_SWL_MATCH:
		case MT_2XSWL_MATCH:
		case MT_UNLIKELY:    // Time out by > 30mins: treat as no match for dupe check
		case MT_OVERLAP:     // Still in the net at the end of the file
			// Do nothing
			break;
		case MT_EXACT:
		case MT_PROBABLE:
			// Delete second occurence after query
			match_question_ = "These appear to be duplicates - select one to delete";
			selection(test_item_, HT_DUPE_QUERY, nullptr, dupe_item_);
			possible_dupe = true;
			break;
		case MT_POSSIBLE:
		case MT_LOC_MISMATCH:
			// Open QSO query 
			match_question_ = "Possible duplicate record found";
			selection(test_item_, HT_DUPE_QUERY, nullptr, dupe_item_);
			possible_dupe = true;
			break;
		}
		if (!possible_dupe) test_item_++;
		status_->progress(test_item_, book_type());
	}
	if (!possible_dupe) {
		char message[256];
		snprintf(message, 256, "LOG: Dupe check complete. %zu checked, %d kept, %d removed", test_item_, number_dupes_kept_, number_dupes_removed_);
		status_->misc_status(ST_OK, message);
		if (number_dupes_removed_ > 0) {
			// Progress will not be complete 
			status_->progress("Check found duplicates", book_type());
		}
		inhibit_view_update_ = false;
		selection(size() - 1, HT_ALL);
		enable_save(true, "Checked dupes");
	}
}

// Handle duplicate action - KEEP_LOG or KEEP_DUPE - delete it
void book::reject_dupe(bool use_dupe) {
	if (use_dupe) {
		selection(dupe_item_, HT_DUPE_DELETED);
	}
	else {
		selection(test_item_, HT_DUPE_DELETED);
	}
	char message[128];
	snprintf(message, 128, "LOG: Duplicate record %s deleted", get_record()->item("CALL").c_str());
	status_->misc_status(ST_WARNING, message);
	delete_record(true);
	number_dupes_removed_++;
}

// Handle duplicate action - MERGE_DUPE - merge and delete it
void book::merge_dupe() {
	get_record(test_item_, false)->merge_records(get_record(dupe_item_, false));
	selection(dupe_item_, HT_DUPE_DELETED);
	char message[128];
	snprintf(message, 128, "LOG: Duplicate record %s merged & deleted", get_record()->item("CALL").c_str());
	status_->misc_status(ST_WARNING, message);
	delete_record(true);
	number_dupes_removed_++;
}

// Handle duplicate action - KEEP_BOTH - ignore and restart check
void book::accept_dupe() {
	char message[128];
	snprintf(message, 128, "LOG: Checked record %s & %s are not duplicates", 
		get_record(test_item_, false)->item("CALL").c_str(),
		get_record(dupe_item_, false)->item("CALL").c_str());
	status_->misc_status(ST_WARNING, message);
	number_dupes_kept_++;
	test_item_++;
}

// Returns the reason record view has been activated - used by record view to prompt the user
std::string book::match_question() {
	return match_question_;
}

// Opens a text editor to allow the header comment to be edited
void book::edit_header() {
	status_->misc_status(ST_NOTE, "LOG: Editting header comment");
	// now read it into the text buffer
	Fl_Text_Buffer* buffer = new Fl_Text_Buffer;
	// Window to display the text editor and Save and Cancel buttons
	Fl_Group* sv = Fl_Group::current();
	Fl_Group::current(nullptr);
	Fl_Window* win = new Fl_Window(640, 480);
	win->label("Header comment");

	// Text editor
	intl_editor* editor = new intl_editor(GAP, HBUTTON + 2 * GAP, 640 - 2 * GAP, 480 - 3 * GAP - HBUTTON);
	editor->buffer(buffer);
	editor->wrap_mode(Fl_Text_Display::WRAP_AT_BOUNDS, 0);
	editor->textfont(FL_COURIER);
	editor->textsize(12);

	// Save button
	Fl_Button* bn_save = new Fl_Button(GAP, GAP, WBUTTON, HBUTTON, "Save");
	bn_save->callback(cb_close_edith, (void*)this);
	// Cancel button
	Fl_Button* bn_cncl = new Fl_Button(GAP + WBUTTON + GAP, GAP, WBUTTON, HBUTTON, "Cancel");
	bn_cncl->callback(cb_cancel_edith, nullptr);
	// Default button
	Fl_Button* bn_default = new Fl_Button(GAP + WBUTTON + GAP + WBUTTON + GAP, GAP, WBUTTON, HBUTTON, "Default");
	bn_default->callback(cb_default_edith, nullptr);
	bn_default->tooltip(default_header_.c_str());
	// Restore button
	Fl_Button* bn_restore = new Fl_Button(bn_default->x() + bn_default->w() + GAP, GAP, WBUTTON, HBUTTON, "Restore");
	bn_restore->callback(cb_restore_edith, (void*)this);
	bn_restore->tooltip("Restore the original header");

	if (header_) {
		// Edit the header
		editor->buffer()->insert(0, header_->header().c_str());
	}
	else {
		// New header
		editor->buffer()->insert(0, default_header_.c_str());
	}
	// Allow editor to resize with window
	win->resizable(editor);
	// Close X button uses same callback as cancel
	win->callback(cb_cancel_edith, (void*)this);
	win->end();
	win->show();

	Fl_Group::current(sv);
}

// Call back to restore default header
void book::cb_default_edith(Fl_Widget* w, void* v) {
	// Find the parent window of the widget (which may itself be the parent)
	Fl_Window* win = w->window();
	if (win == nullptr) win = (Fl_Window*)w;
	intl_editor* editor = nullptr;
	// Look at each child of the window until we find that is a text editor
	for (int i = 0; i < win->children() && editor == nullptr; i++) {
		editor = dynamic_cast<intl_editor*>(win->child(i));
	}
	// If we do find a text editor update the header from its current text
	if (editor) {
		editor->buffer()->remove(0, editor->buffer()->length());
		editor->buffer()->insert(0, default_header_.c_str());
	}
}

// Callback to retore original header value
void book::cb_restore_edith(Fl_Widget* w, void* v) {
	// Find the parent window of the widget (which may itself be the parent)
	Fl_Window* win = w->window();
	if (win == nullptr) win = (Fl_Window*)w;
	intl_editor* editor = nullptr;
	// Look at each child of the window until we find that is a text editor
	for (int i = 0; i < win->children() && editor == nullptr; i++) {
		editor = dynamic_cast<intl_editor*>(win->child(i));
	}
	// If we do find a text editor update the header from its current text
	if (editor) {
		book* that = (book*)v;
		editor->buffer()->remove(0, editor->buffer()->length());
		editor->buffer()->insert(0, that->header()->header().c_str());
	}
}

// Call back to save the new header value
void book::cb_close_edith(Fl_Widget* w, void* v) {
	// Find the parent window of the widget (which may itself be the parent)
	Fl_Window* win = w->window();
	if (win == nullptr) win = (Fl_Window*)w;
	intl_editor* editor = nullptr;
	// Look at each child of the window until we find that is a text editor
	for (int i = 0; i < win->children() && editor == nullptr; i++) {
		editor = dynamic_cast<intl_editor*>(win->child(i));
	}
	// If we do find a text editor update the header from its current text
	if (editor) {
		book* that = (book*)v;
		if (!that->header_) {
			that->header_ = new record();
		}
		that->header_->header(std::string(editor->buffer()->text()));
	}
	menu_->enable(true);
	status_->misc_status(ST_OK, "LOG: Editting header comment - Done!");
	Fl_Window::default_callback(win, v);
}

// Call back to cancel the new header edit
void book::cb_cancel_edith(Fl_Widget* w, void* v) {
	// Find the parent window of the widget (which may itself be the parent)
	Fl_Window* win = w->window();
	if (win == nullptr) win = (Fl_Window*)w;
	status_->misc_status(ST_OK, "LOG: Editting header comment - Cancelled!");
	Fl_Window::default_callback(win, v);
}

// Return delete in progress - used to disable menu items
bool book::delete_enabled() {
	if (delete_in_progress_) {
		return false;
	}
	else {
		return true;
	}
}

// Upload the latest QSO imported to eQSL, LotW and Clublog
bool book::upload_qso(qso_num_t record_num) {
	if (AUTO_UPLOAD && upload_allowed_) {
		record* qso = get_record(item_number(record_num), false);
		enable_save(false, "Uploading to QSL sites");
		bool ok = true;
		if (qso->item("EQSL_QSL_SENT") != "Y") 
			if (!eqsl_handler_->upload_single_qso(record_num)) ok = false;
		if (qso->item("LOTW_QSL_SENT") != "Y") 
			if (!lotw_handler_->upload_single_qso(record_num)) ok = false;
		if (qso->item("CLUBLOG_UPLOAD_QSL_STATUS") != "Y") 
			if (!club_handler_->upload_single_qso(record_num)) ok = false;
		if (qso->item("QRZCOM_QSO_UPLOAD_STATUS") != "Y") {
			if (!qrz_handler_->upload_single_qso(record_num)) ok = false;
		}
		// Clear flag as already handled new record features
		new_record_ = false;
		enable_save(true, "Upload to QSL sites requested");
		return ok;
	} else {
		status_->misc_status(ST_WARNING, "LOG: QSO uploads inhibited");
		return false;
	}
}

// Return the been_modified_ flag
bool book::been_modified() {
	return is_dirty();
}

// return entrring new record
bool book::enterring_record() {
	return new_record_ || is_dirty_record(get_record());
}

// Find the most recent QSO that is the gap after the previous one and std::set that as session start
void book::set_session_start() {
	if (RESUME_SESSION && size()) session_start_ = get_record(size() - 1, false)->timestamp();
	else session_start_ = time(nullptr);
	Fl_Preferences settings(prefs_mode_, VENDOR.c_str(), PROGRAM_ID.c_str());
	Fl_Preferences user_settings(settings, "User Settings");
	Fl_Preferences log_settings(user_settings, "Log Table");
	double session_gap_mins;
	log_settings.get("Session Gap", session_gap_mins, 30.0);
	if (size()) {
		// Start at end of book
		bool found = false;
		qso_num_t rec_num = size() - 1;
		while (rec_num > 0 && !found) {
			time_t qso_time = get_record(rec_num, false)->timestamp();
			if (difftime(session_start_, qso_time) < (session_gap_mins * 60.0)) {
				session_start_ = qso_time;
			}
			else {
				found = true;
			}
			rec_num--;
		}
	} 
	// Display the start time in the status log
	char stime[100];
	tm* start_time = gmtime(&session_start_);
	strftime(stime, 100, "%Y/%m/%d %H:%M:%S", start_time);
	char message[256];
	snprintf(message, 256, "ZZALOG: Setting session start at %s", stime);
	status_->misc_status(ST_NOTE, message);
}

// Get the fraction of file loaded or stored - used in qso_log_info display
double book::get_complete() {
	if (adi_reader_) return adi_reader_->progress();
	else if (adi_writer_) return adi_writer_->progress();
	else if (adx_reader_) return adx_reader_->progress();
	else if (adx_writer_) return adx_writer_->progress();
	else return 0.0;
}

// The book is being loaded (one of the readers is active)
bool book::loading() {
	return (adi_reader_ != nullptr || adx_reader_ != nullptr);
}

// The book is being stored (on of the writers is active)
bool book::storing() {
	return (adi_writer_ != nullptr || adx_writer_ != nullptr);
}

// Used to temporarily disable the upload of QSLs
void book::allow_upload(bool enable) {
	upload_allowed_ = enable && AUTO_UPLOAD;
}

// Set the filename
void book::set_filename(std::string filename) {
	if (size()) {
		char msg[128];
		snprintf(msg, sizeof(msg), "LOG: %s Not empty - use \"Save as\" to save as %s",
			filename_.c_str(), filename.c_str());
	} else {
		filename_ = filename;
		spec_data_->loaded_filename(filename_);
		main_window_label(filename_);
	}
}

// Is this QSO record in te book?
bool book::has_record(record* qso) {
	item_num_t num = get_insert_point(qso);
	if (get_record(num, false) == qso) return true;
	else return false;
}

// Add this record to the dirty std::set
void book::add_dirty_record(record* qso, std::string reason) {
	if (has_record(qso)) { 
		if (!main_loading_)
			printf("%s Marking %s %s %s dirty - %s\n",
				OBJECT_NAMES.at(book_type_),
				qso->item("QSO_DATE").c_str(),
				qso->item("TIME_ON").c_str(),
				qso->item("CALL").c_str(),
				reason.c_str());
		dirty_qsos_.insert(qso);
	}
	else if (qso == header_) {
		if (!main_loading_)
			printf("%s Marking header dirty - %s", OBJECT_NAMES.at(book_type_), reason.c_str());
		dirty_qsos_.insert(qso);
	}
}

// Remove this record from the dirty std::set
void book::delete_dirty_record(record* qso) {
	if (is_dirty_record(qso)) {
		printf("%s Marking %s %s %s clean\n",
			OBJECT_NAMES.at(book_type_),
			qso->item("QSO_DATE").c_str(),
			qso->item("TIME_ON").c_str(),
			qso->item("CALL").c_str());
		dirty_qsos_.erase(qso);
	}
}

// Are there any dirty records
bool book::is_dirty() {
	size_t num_dirty = dirty_qsos_.size();
	bool result = num_dirty != 0 || deleted_record_;
	return result;
}

// Is this record dirty
bool book::is_dirty_record(record* qso) {
	return (dirty_qsos_.find(qso) != dirty_qsos_.end());
}
