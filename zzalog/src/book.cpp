#include "book.h"
#include "adi_reader.h"
#include "adi_writer.h"
#include "adx_reader.h"
#include "adx_writer.h"
#include "tsv_writer.h"
#include "view.h"
#include "status.h"
#include "menu.h"
#include "tabbed_forms.h"
#include "spec_data.h"
#include "spec_tree.h"
#include "pfx_data.h"
#include "prefix.h"
#include "utils.h"
#include "intl_widgets.h"
#include "band_view.h"
#include "eqsl_handler.h"
#include "lotw_handler.h"
#include "club_handler.h"
#include "main_window.h"

// C/C++ header files
#include <ctime>
// FLTK header files
#include <FL/Fl.H>
#include <FL/fl_ask.H>
#include <FL/Fl_Menu_Item.H>
#include <FL/Fl_Preferences.H>
#include <FL/Fl_Single_Window.H>



using namespace std;

// Global data items
extern status* status_;
extern menu* menu_;
extern tabbed_forms* tabbed_forms_;
extern spec_data* spec_data_;
extern spec_tree* spec_tree_;
extern pfx_data* pfx_data_;
extern Fl_Preferences* settings_;
extern main_window* main_window_;
extern band_view* band_view_;
extern book* book_;
extern eqsl_handler* eqsl_handler_;
extern lotw_handler* lotw_handler_;
extern club_handler* club_handler_;
extern bool read_only_;
extern void main_window_label(string text);
extern string PROGRAM_ID;
extern string PROGRAM_VERSION;
extern time_t session_start_;


const string default_header_ = "ADIF File generated by ZZALOG\n";

// Constructor - initialises some attributes
book::book()
	: book_type_(OT_MAIN)
	, modified_record_(false)
	, new_record_(false)
	, header_(nullptr)
	, inhibit_view_update_(false)
	, current_item_(0)
	, modified_(false)
	, filename_("")
	, format_(FT_ADI)
	, criteria_(nullptr)
	, last_search_result_(0)
	, save_in_progress_(false)
	, delete_in_progress_(false)
	, old_record_(nullptr)
	, been_modified_(false)
	, main_loading_(false)
	, ignore_gridsquare_(false)
	, save_level_(0)
{
	used_bands_.clear();
	used_modes_.clear();
	used_submodes_.clear();
	used_rigs_.clear();
	used_antennas_.clear();
	used_callsigns_.clear();
	used_qths_.clear();
	delete_contents(true);
}

// Destructor - iterative destroys contents
book::~book()
{
	// Just destroy the contents
	delete_contents(false);
}

// constructor to open a file and populate book
bool book::load_data(string filename)
{
	bool ok = false;
	if (book_type_ == OT_MAIN || book_type_ == OT_IMPORT) {
		// Only book types we should load
		// selection for the below choice
		enum choice_t : int {
			SAVE = 0,
			DONT_SAVE = 1,
			CANCEL = 2
		};
		choice_t choice = SAVE;
		if (modified()) {
			// If the current data is modified, ask the user if it should be saved first
			fl_beep(FL_BEEP_QUESTION);
			choice = (choice_t)fl_choice("Current file is modified - do you want to save the changes?", "Save", "Don't Save", "Cancel");
			if (choice == SAVE) {
				store_data();
			}
		}
		if (choice != CANCEL) {
			// delete current contents (main only) - also stuff created by book
			if (book_type_ == OT_MAIN) {
				delete_contents(true);
			}

			// not called File->New
			if (filename.length() != 0) {
				// remember filename and tell ADIF spec database
				this->filename_ = filename;
				spec_data_->loaded_filename(filename_);
				// Update status bar
				char* message = new char[filename_.length() + 20];
				sprintf(message, "LOG: %s", filename_.c_str());
				status_->misc_status(ST_NOTE, message);
				delete[] message;
				// Get the filetype suffix from the filename to know which reader to use
				string filetype;
				size_t last_period = filename.find_last_of('.');
				if (last_period != string::npos) {
					filetype = to_lower(filename.substr(last_period));
				}
				size_t last_slash = filename.find_last_of("/\\");
				if (last_slash != string::npos) {
					string file_directory = filename.substr(0, last_slash);
					Fl_Preferences datapath_settings(settings_, "Datapath");
					datapath_settings.set("Log Directory", file_directory.c_str());
				}
				// Check for .adi or .adif format
				if (filetype == ".adi" || filetype == ".adif") {
					// Use ADI reader to read from an input stream connected to thefile
					adi_reader* reader = new adi_reader;
					input_.open(filename.c_str(), fstream::in);
					// Load the book
					if (book_type_ == OT_MAIN) {
						status_->file_status(FS_LOADING);
						main_loading_ = true;
					}
					if (!reader->load_book(this, input_)) {
						// Error while reading book
						char message[256];
						sprintf(message, "LOG: Failed to open %s", filename.c_str());
						status_->misc_status(ST_ERROR, message);
						if (book_type_ == OT_MAIN) {
							// Display message in main window title and update views that there's no or partial data
							main_window_label("[load failed]");
							selection(0, HT_NO_DATA);
							//Fl::wait();
						}
						delete reader;
						ok = false;
					}
					else {
						if (book_type_ == OT_MAIN) {
							main_loading_ = false;
							// Display filename in title bar and update views there's new data
							if (read_only_) {
								main_window_label(filename + " [read-only]");
							}
							else {
								main_window_label(filename);
							}
							selection(size() - 1, HT_NEW_DATA, nullptr);
							if (modified()) {
								status_->file_status(FS_MODIFIED);
							}
							else {
								status_->file_status(FS_SAVED);
							}
							// Parse and validate
//							Fl::wait();
						}
						delete reader;
						ok = true;
					}
					input_.close();
					if (format_ == FT_ADX) {
						// We have already loaded ADX data 
						status_->misc_status(ST_WARNING, "LOG: Loading .adi format when .adx already loaded, validation will be compromised");
						format_ = FT_MIXED;
					}
					else {
						// Set the format to ADI - this affects validation
						format_ = FT_ADI;
					}
				}
				// Check for .adx format
				else if (filetype == ".adx") {
					// Use ADX reader to load the data from the file through an input stream
					adx_reader* reader = new adx_reader;
					// Opening in text mode appears to do some behind-the-scenes processing
					// when seeking backwards passed NL.
					input_.open(filename.c_str(), fstream::in | fstream::binary);
					status_->file_status(FS_LOADING);
					main_loading_ = true;
					if (!input_.good() || !reader->load_book(this, input_)) {
						// Failed to complete the load
						char * message = new char[filename.length() + reader->information().length() + 100];
						sprintf(message, "LOG: Failed to open %s. Error messages = %s", filename.c_str(), reader->information().c_str());
						status_->misc_status(ST_ERROR, message);
						delete[] message;
						clear();
						if (book_type_ == OT_MAIN) {
							// Update title bar and tell views
							main_window_label("[load failed]");
							selection(0, HT_NO_DATA);
							//Fl::wait();
						}
						delete reader;
						ok = false;
					}
					else {
						if (book_type_ == OT_MAIN) {
							// Update title bar and tell views
							main_loading_ = false;
							if (read_only_) {
								main_window_label(filename + " [read-only]");
							}
							else {
								main_window_label(filename);
							}
							selection(size() - 1, HT_NEW_DATA);
							if (modified()) {
								status_->file_status(FS_MODIFIED);
							}
							else {
								status_->file_status(FS_SAVED);
							}
							// Parse and validate
							//Fl::wait();
						}
						delete reader;
						ok = true;
					}
					input_.close();
					if (format_ == FT_ADI) {
						// Mixed source
						status_->misc_status(ST_WARNING, "LOG: Loading .adi format when .adx already loaded, validation will be compromised");
						format_ = FT_MIXED;
					}
					else {
						// Remeber ADX for validation
						format_ = FT_ADX;
					}

					ok = false;
				}
				// neither .adi nor .adx 
				else {
					char* message = new char[filename.length() + 100];
					sprintf(message, "LOG: Unknown file format. %s ignored", filename.c_str());
					status_->misc_status(ST_ERROR, message);
					delete[] message;
					ok = false;
				}
				if (ok) {
					char* message = new char[filename.length() + 100];
					sprintf(message, "LOG: %d records read from %s", size(), filename.c_str());
					status_->misc_status(ST_OK, message);
					delete[] message;
				}
				set_session_start();
				// Update spec_data
				for (auto mx = used_qths_.begin(); mx != used_qths_.end(); mx++) {
					spec_data_->add_user_macro("APP_ZZA_QTH", (*mx).first, *((*mx).second));
				}
				tabbed_forms_->update_views(nullptr, HT_ALL, size() - 1);
				// TODO: Review how to update spec_data that is dependent on read in values 
				// do the following for now
				tabbed_forms_->update_views(nullptr, HT_FORMAT, size() - 1);
			}
			else { // filename.length() == 0 (File->New)
				main_window_label("[No file loaded]");
				// Create a header record
				record* header = new record();
				this->header(header);
				header_->header(default_header_);
				// tell views there is no data to display
				selection(0, HT_NO_DATA);
				Fl::redraw();
				ok = true;
			}
		}
		else { // choice == CANCEL
			ok = false;
		}
	}
	else {
		// Cannot load other types.
		status_->misc_status(ST_ERROR, "LOG: An extract or export type of book cannot be constructed by reading a file");
		ok = false;
	}
	return ok;
}

// Store data - only if modified or force is true. If fields is defined only output specified fields
bool book::store_data(string filename, bool force, set<string>* fields) {
	bool ok = false;
	if (save_in_progress_) {
		// Race hazard - can instigate a second store before finished this one
		status_->misc_status(ST_WARNING, "LOG: Ignoring request to store log as currently doing so");
	}
	else {
		if (book_type_ == OT_MAIN || book_type_ == OT_EXTRACT) {
			// can only write out main log or extracted records
			save_in_progress_ = true;
			// Check we are not in the middle of modifying a record 
			if (new_record()) {
				// Clear this first to avoid iteration through this question
				fl_beep(FL_BEEP_QUESTION);
				switch (fl_choice("You are currently adding a record? Save or Quit?", "Save?", "Quit?", nullptr)) {
				case 0:
					break;
				case 1:
					// Quit - delete any new record
					delete_record(new_record());
					break;
				}
				new_record_ = false;
			}

			// First parse and validate if necessary
			if (modified() == true || force) {
				// Only write out if modified or force is set
				if (!header_) {
					// No header then create one.
					header_ = new record;
					header_->header(" ");
				} else {
					// Add a single space comment if there is not an existing comment.
					if (header_->header().length() == 0) {
						header_->header(" ");
					}
				}
				// Update header specific items
				header_->item("PROGRAMID", PROGRAM_ID);
				header_->item("PROGRAMVERSION", PROGRAM_VERSION);
				header_->item("ADIF_VER", spec_data_->adif_version());

				// use supplied filename (for Save As) or remembered filename (for Save)
				if (filename != "") {
					filename_ = filename;
				}
				// Update status bar
				char * message = new char[filename_.length() + 20];
				sprintf(message, "LOG: %s", filename_.c_str());
				status_->misc_status(ST_NOTE, message);
				delete[] message;
				// Output stream
				ofstream file;
				// Get file type suffix
				string filetype = "";
				size_t last_period = filename_.find_last_of('.');
				if (last_period != string::npos) {
					// Get file type
					filetype = to_lower(filename_.substr(last_period));
				}
				size_t last_slash = filename.find_last_of("/\\");
				if (last_slash != string::npos) {
					string file_directory = filename.substr(0, last_slash);
					Fl_Preferences datapath_settings(settings_, "Datapath");
					datapath_settings.set("Log Directory", file_directory.c_str());
				}
				// Check for .adi format
				if (filetype == ".adi" || filetype == ".adif") {
					// Connect file to output stream and get ADI writer to write it
					if (book_type_ == OT_MAIN) {
						status_->file_status(FS_SAVING);
					}
					file.open(filename_.c_str(), fstream::out);
					adi_writer* writer = new adi_writer;
					if (writer->store_book(this, file, book_type_ == OT_MAIN ? true : false, fields) != LR_GOOD) {
						// Store failed
						char* message = new char[filename_.length() + 100];
						sprintf(message, "LOG: Failed to open %s", filename_.c_str());
						delete[] message;
						file.close();
						ok = false;
					}
					else {
						ok = true;
					}
					delete writer;
				}
				// check for .adx format
				else if (filetype == ".adx") {
					// Connect file to output stream and store data
					if (book_type_ == OT_MAIN) {
						status_->file_status(FS_SAVING);
					}
					file.open(filename_.c_str(), fstream::out);
					adx_writer* writer = new adx_writer;
					if (!writer->store_book(this, file, book_type_ == OT_MAIN ? true: false)) {
						// Store failed
						char * message = new char[filename_.length() + 100];
						sprintf(message, "LOG: Failed to open %s", filename_.c_str());
						status_->misc_status(ST_ERROR, message);
						delete[] message;
						file.close();
						ok = false;
					}
					else {
						ok = true;
					}
					delete writer;
				}
				// check for .tsv format
				else if (filetype == ".tsv" || filetype == ".tab") {
					// Connect file to output stream and store data
					file.open(filename_.c_str(), fstream::out);
					tsv_writer* writer = new tsv_writer;
					if (!writer->store_book(this, file, fields)) {
						// Store failed
						char * message = new char[filename_.length() + 100];
						sprintf(message, "LOG: Failed to open %s", filename_.c_str());
						status_->misc_status(ST_ERROR, message);
						delete[] message;
						file.close();
						ok = false;
					}
					else {
						ok = true;
					}
					delete writer;
				}
				else {
					// Unknown file type
					char * message = new char[filename_.length() + 100];
					sprintf(message, "LOG: Unknown file format. %s ignored", filename_.c_str());
					status_->misc_status(ST_WARNING, message);
					delete[] message;
					ok = false;
				}
				if (ok) {
					char* message = new char[filename_.length() + 100];
					sprintf(message, "LOG: %d records written to %s", size(), filename_.c_str());
					status_->misc_status(ST_OK, message);
					delete[] message;
				}
				if (ok && book_type_ == OT_MAIN) {
					// As file has been stored, clear modified flag
					modified(false);
					modified_record(false);
					// File was closed in the fail paths
					file.close();
					// Update file name on window label
					main_window_label(filename_);
				}
			}
			else {
				ok = false;
			}
			save_in_progress_ = false;
		}
		else {
			// Cannot write an imported file
			char message[256];
			snprintf(message, 256, "LOG: Attempting to write %s - this book is not writeable", (filename == "" ? filename_.c_str() : filename.c_str()));
			status_->misc_status(ST_ERROR, message);
			ok = false;
		}
	}
	// Update menu item activeness - redraw log tables to remove modified hue
	tabbed_forms_->update_views(nullptr, HT_FORMAT, 0);
	menu_->update_items();
	return ok;
}

// Get the current selected record - return NULL if current_record beyond the size of array
record* book::get_record() {
	if (current_item_ < size()) {
		return at(current_item_);
	}
	else {
		return NULL;
	}
}

// Get the numbered record and optionally select it (quietly)
record* book::get_record(item_num_t num_item, bool set_selected/* = true*/) {
	if (num_item < size()) {
		if (set_selected) {
			// Set the selected record
			current_item_ = num_item;
		}
		return at(num_item);
	}
	else {
		// item number beyond the size of the book
		return NULL;
	}
}

// Get the last recod in book
record* book::get_latest() {
	return get_record(size() - 1, false);
}

// Copy the current record
void book::remember_record() {
	// Assume we are changing selection so if the record is unmodified save its contents
	if (!modified_record_ && !new_record() && book_type_ == OT_MAIN) {
		delete old_record_;
		old_record_ = new record(*get_record(current_item_, false));
	}
}

// Change the selected record (& update any necessary controls
item_num_t book::selection(item_num_t num_item, hint_t hint /* = HT_SELECTED */, view* requester /* = nullptr */, item_num_t num_other /*= 0*/) {
	if (save_in_progress_) {
		status_->misc_status(ST_WARNING, "LOG: Currently storing the book, cannot change selection");
		return current_item_;
	}
	else {
		item_num_t previous = current_item_;
		// Special case - -1 indicates no change to the selection
		if ((signed)num_item != -1 && size()) {
			current_item_ = num_item;
			remember_record();
		}
		else {
		}
		record* this_record = get_record(current_item_, false);
		qso_num_t record_num = record_number(current_item_);
		// update turned off during certain activities
		switch (hint) {
		case HT_IMPORT_QUERY:
		case HT_IMPORT_QUERYNEW:
		case HT_DUPE_QUERY:
			// Query against first record in import_data or identified record
			tabbed_forms_->update_views(requester, hint, record_num, record_number(num_other));
			break;
		case HT_CHANGED:
		case HT_MINOR_CHANGE:
			if (!inhibit_view_update_) {
				// Set modified flag
				modified(true);
				// Update to this record
				tabbed_forms_->update_views(requester, hint, record_num);
			}
			break;
		case HT_INSERTED:
		case HT_DELETED:
			if (!inhibit_view_update_) {
				// Set modified flag
				modified(true);
				// Update to this record
				tabbed_forms_->update_views(requester, hint, record_num);
			}
			break;
		case HT_START_CHANGED:
			// The QSO start date has been changed. Re-order the book and tell everyone
			this_record = get_record(current_item_, false);
			erase(begin() + current_item_);
			record_num = insert_record(this_record);
			modified(true);
			tabbed_forms_->update_views(requester, HT_ALL, record_num);
			break;
		default:
			if (!inhibit_view_update_) {
				tabbed_forms_->update_views(requester, hint, record_num);
			}
			break;
		}
		if (current_item_ != previous && !read_only_ && save_level_ == 0 && modified() && !save_in_progress_) {
#ifndef _DEBUG
			store_data();
#endif // _DEBUG
		}
		// Update menu item activeness
		menu_->update_items();
		return record_num;
	}
}

// Get the current selected item
item_num_t book::selection() {
	return current_item_;
}

// Insert a record in its chronological position 
qso_num_t book::insert_record(record* record) {
	// Get the offset where to add the record and insert it into the array
	item_num_t pos_record = get_insert_point(record);
	insert_record_at(pos_record, record);
	return pos_record;
}

// Append a record at the end of the book
item_num_t book::append_record(record* record) {
	item_num_t pos_record = size();
	insert_record_at(pos_record, record);
	return pos_record;
}

// add a header record
void book::header(record* header) {
	delete header_;
	header_ = header;
}

// return the header record
record* book::header() {
	return header_;
}

// Delete all records and tidy up
void book::delete_contents(bool new_book) {
	// Delete the individual records
	for (auto it = begin(); it != end(); it++) {
		delete *it;
	}
	// Clear the array
	clear();
	// Set it unmodified
	modified(false);
	filename_ = "";
	format_ = FT_NONE;
	delete header_;
	header_ = nullptr;
	// Delate all informationed maintained about data
	used_modes_.clear();
	used_bands_.clear();
	used_submodes_.clear();
	if (new_book && book_type_ == OT_MAIN) {
		// Delete all non-ADIF defined fields 
		spec_data_->delete_user_data();
		spec_data_->delete_appdefs();
		spec_data_->delete_userdefs();
		// Restore this app's app-defined fields
		spec_data_->add_my_appdefs();

	}
	if (book_type_ == OT_MAIN) {
		// Update status to empty
		status_->file_status(FS_EMPTY);
		main_loading_ = false;
	}
}

// Return count of records
item_num_t book::get_count() {
	return size();
}

// returns the position at which to chronologically insert a record
item_num_t book::get_insert_point(record* record) {
	// Find where to insert the record
	// operator> overloaded to compare Record date and start time
	// Check at tail as new record likely to be a more recent one.
	item_num_t upper_bound = size() == 0 ? 0 : size() - 1;
	item_num_t lower_bound = 0;
	item_num_t next_bound;

	// if the book is empty add to the beginning 
	if (size() == 0) {
		return 0;
	}
	// if the record is later than the last in the book.
	else if (*record > *(at(upper_bound))) {
		return size();
	}
	else {
		// Check at beginning - is it earlier?
		if (!(*record > *(at(0)))) {
			return 0;
		}
		else {
			// Binary slice the array until found
			// Keep comparing the record between upper bound and lower bound
			// until the gap between them is nil. then put it there.
			while (upper_bound - 1 != lower_bound) {
				// Compare with the half-way point 
				next_bound = (lower_bound + upper_bound) / 2;
				if (*record > *(at(next_bound))) {
					// It's between half-way and upper-bound, move lower-bound to half-way
					lower_bound = next_bound;
				}
				else {
					// It's between half-way and lower-bound, move upper-bound to half-way
					upper_bound = next_bound;
				}
			}
			return upper_bound;
		}
	}
}

// insert the record at specific position
void book::insert_record_at(item_num_t pos_record, record* record) {
	// get the iterator to the insert position
	insert(begin() + pos_record, record);
	if (book_type_ == OT_MAIN) {
		// Update summary lookups
		add_use_data(record);
	}
}

// Navigate the log - i.e. go to specific position
void book::navigate(navigate_t target) {
	switch (target) {
	case NV_FIRST:
		// Select first record
		selection(0);
		break;
	case NV_PREV:
		// Select previous record
		if (selection() != 0) {
			selection(selection() - 1);
		}
		break;
	case NV_LAST:
		// Select last record
		selection(size() - 1);
		break;
	case NV_NEXT:
		// select next record 
		if (selection() != size() - 1) {
			selection(selection() + 1);
		}
		break;
	}
}

// Go to the date specified
void book::go_date(string date) {
	// set the bounds of the search - binary split search
	item_num_t u_bound = size() - 1;
	item_num_t l_bound = 0;
	// Continue until a gap of only 1 between upper and lower bounds of the search
	while (u_bound - l_bound > 1) {
		// Compare string form of dates
		string u_date = at(u_bound)->item("QSO_DATE");
		string l_date = at(l_bound)->item("QSO_DATE");
		if (u_date < date) {
			// Date later than last record considered - force loop to end
			l_bound = u_bound;
		}
		else if (l_date > date) {
			// Date earlier than first record considered - force loop to end
			u_bound = l_bound;
		}
		else {
			// Now implement binary search - repeatedly halving search range 
			item_num_t mid_pos = (l_bound + u_bound) / 2;
			string m_date = at(mid_pos)->item("QSO_DATE");
			if (m_date > date) {
				// Date in earlier half
				u_bound = mid_pos;
			}
			else {
				// Daate in later half
				l_bound = mid_pos;
			}
		}
	}
	// Selected the earlier of the two records
	selection(l_bound);
}

// Set the modified flag - conditionally update the status progress bar (as indication it's modified
void book::modified(bool value, bool update_progress /*= true*/) {
	// Set the flag
	modified_ = value;
	if (modified_) {
		been_modified_ = true;
	}
	if (book_type_ == OT_MAIN) {
		// Only change file status for main book
		if (modified_) {
			// Set the progress bar to indicate it's been modified
			status_->file_status(FS_MODIFIED);
		}
		else {
			// If the main book is empty indicate so.
			if (get_count() == 0) {
				status_->file_status(FS_EMPTY);
			}
			else {
				status_->file_status(FS_SAVED);
			}
		}
	}
}

// Return the modified flag
bool book::modified() {
	return modified_;
}


// return the filename
string book::filename(bool full /*=true*/) {
	if (full) {
		// Returns full filename
		return filename_;
	}
	else {
		// Return the filename after the last slash
		size_t pos = filename_.find_last_of("/\\");
		return filename_.substr(pos + 1);
	}
}

// delete the selected record - force set if not created the record through book API
void book::delete_record(bool force) {
	// Either entering a new record or user allows to delete a saved record
	if (force || new_record_) {
		// We cannot delete two records at once as it confuses the value of current_item_
		if (delete_in_progress_) {
			status_->misc_status(ST_WARNING, "LOG: Delete record inhibited");
		}
		else {
			// Update status bar and menu items
			char text[128];
			sprintf(text, "LOG: Deleting record %s %s %s",
				get_record()->item("QSO_DATE").c_str(),
				get_record()->item("TIME_ON").c_str(),
				get_record()->item("CALL").c_str());
			status_->misc_status(ST_NOTE, text);
			delete_in_progress_ = true;
			menu_->update_items();
			// Remove the current record from both the book_ and the extract_data_
			if (book_type_ == OT_EXTRACT) {
				book_->erase(book_->begin() + record_number(current_item_));
			} 
			erase(begin() + current_item_);
			new_record_ = false;
			modified_record_ = false;
			modified(true);
			// if current record no longer exists decrement it (exept if already first record)
			if (current_item_ == size() && current_item_ > 0) {
				current_item_--;
			}
			// Tell the views a record has been deleted and to redraw from the current selection
			selection(current_item_, HT_DELETED);
			// After selection has done its all can allow another delete
			delete_in_progress_ = false;
			menu_->update_items();
		}
	}
	else if (modified_record_) {
		// Update status bar and menu items
		char text[128];
		sprintf(text, "LOG: Canceling edit record %s %s %s",
			get_record()->item("QSO_DATE").c_str(),
			get_record()->item("TIME_ON").c_str(),
			get_record()->item("CALL").c_str());
		status_->misc_status(ST_NOTE, text);
		// Cancel record edit.
		*get_record() = *old_record_;
		delete old_record_;
		old_record_ = nullptr;
		modified_record_ = false;
		// Because we have not updated other views yet, we only regard this as a minor change
		selection(-1, HT_MINOR_CHANGE);
		menu_->update_items();
	}
}

// Move the record to its correct chronological position
item_num_t book::correct_record_position(item_num_t current_pos) {
	// First delete the old position so it doesn't confuse GetOffset
	// Save the record first
	record* this_record = get_record(current_pos, false);
	// remove record at existing position
	erase(begin() + current_pos);
	// now insert it in the correct position and other bookkeeping
	return insert_record(this_record);
}

// Returns whether a record matches the search criteria
bool book::match_record(record* record) {
	// Two level matching
	bool match = basic_match(record) && refine_match(record);
	return match;
}

// Returns whether a record matches the basic search condition.
bool book::basic_match(record* record) {
	string::size_type dummy = 0;
	// See if record matches criterion
	switch (criteria_->condition) {
	case XC_UNFILTERED:
		// match all records
		return true;
	case XC_CALL:
		// match by callsign
		return match_string(criteria_->pattern, criteria_->comparator, record->item("CALL"));
		break;
	case XC_CONT:
		// match by continent
		return match_string(criteria_->pattern, criteria_->comparator, record->item("CONT"));
		break;
	case XC_CQZ:
		// match by CQ Zone number
		return match_int(criteria_->pattern, criteria_->comparator, record->item("CQZ"));
		break;
	case XC_DXCC:
		// all numeric so its a DXCC code
		if (is_integer(criteria_->pattern)) {
			return match_int(criteria_->pattern, criteria_->comparator, record->item("DXCC"));
		}
		else {
			// Treat as a nickname
			prefix* dxcc_pfx = pfx_data_->get_prefix(criteria_->pattern);
			if (dxcc_pfx != nullptr && dxcc_pfx->dxcc_code_ != 0) {
				return match_string(to_string(dxcc_pfx->dxcc_code_), criteria_->comparator, record->item("DXCC"));
			}
		}
		break;
	case XC_FIELD:
		// match by a specified field
		return match_string(criteria_->pattern, criteria_->comparator, record->item(criteria_->field_name));
		break;
	case XC_GEO: {
		// match by the "geography" - based on default prefix for that region
		prefix* prefix = pfx_data_->get_prefix(record->item("APP_ZZA_PFX"));
		bool match = false;
		while (!match && prefix != nullptr && prefix->parent_ != nullptr) {
			return match_string(criteria_->pattern, criteria_->comparator, prefix->nickname_);
			prefix = prefix->parent_;
		}
		break;
	}
	case XC_ITUZ:
		// match by ITU zone number
		return match_int(criteria_->pattern, criteria_->comparator, record->item("ITUZ"));
		break;
	case XC_SQ2:
		// match by first two characters of locator
		// condition too short
		if (criteria_->pattern.length() < 2) break;
		// gridsquare in record too short
		if (criteria_->comparator != XP_REGEX && record->item("GRIDSQUARE").length() < 2) break;
		return match_string(criteria_->pattern.substr(0, 2), criteria_->comparator, record->item("GRIDSQUARE").substr(0, 2));
		break;
	case XC_SQ4:
		// match by first 4 charactes of locator
		if (criteria_->pattern.length() < 4) break;
		if (criteria_->comparator != XP_REGEX && record->item("GRIDSQUARE").length() < 4) break;
		return match_string(criteria_->pattern.substr(0, 4), criteria_->comparator, record->item("GRIDSQUARE").substr(0, 4));
		break;
	}
	// we should never get here
	return false;
}

// refine match - by date, band, mode or confirmation
bool book::refine_match(record* record) {
	// now refine by dates
	if (criteria_->by_dates) {
		string record_date = record->item("QSO_DATE");
		// confirm the match is between specified dates - inclusive
		if (record_date < criteria_->from_date || record_date > criteria_->to_date) {
			return false;
		}
	}
	// now refine by band - confirm if the record is on that band
	if (criteria_->band != "Any" && criteria_->band != record->item("BAND")) {
		return false;
	}
	// Refine by mode - confirm if the record has that mode (converted to DXCC modes PHONE, CW, DATA)
	if (criteria_->mode != "Any" && criteria_->mode != record->item("MODE")) {
		return false;
	}
	// Refine by eQSL card - confirm if eQSL confirmation
	if (criteria_->confirmed_eqsl && record->item("EQSL_QSL_RCVD") != "Y") {
		return false;
	}
	// Refine by LotW - confirm if LotW confirmation
	if (criteria_->confirmed_eqsl && record->item("LOTW_QSL_RCVD") != "Y") {
		return false;
	}
	// Refine by card - confirm if card confirmation
	if (criteria_->confirmed_card && record->item("QSL_RCVD") != "Y") {
		return false;
	}
	return true;
}

// string item matches taking whether to use regex or not.
bool book::match_string(string test, search_comp_t comparator, string value) {
	basic_regex<char> regex(to_upper(test));
	switch (comparator) {
	case XP_REGEX:
		return regex_match(to_upper(value), regex);
	case XP_NE:
		return (to_upper(value) != to_upper(test));
	case XP_LT:
		return (to_upper(value) < to_upper(test));
	case XP_LE:
		return (to_upper(value) <= to_upper(test));
	case XP_EQ:
		return (to_upper(value) == to_upper(test));
	case XP_GE:
		return (to_upper(value) >= to_upper(test));
	case XP_GT:
		return (to_upper(value) > to_upper(test));
	default:
		return false;
	}
}

// integer item matching - ignores things like leading zeros and trailing non numeric characters
bool book::match_int(string value, search_comp_t comparator, string test) {
	try {
		return match_int(stoi(value), comparator, stoi(test));
	}
	catch (const invalid_argument&) {
		return false;
	}
}

// integer item matching - integer vs integer
bool book::match_int(int value, search_comp_t comparator, int test) {
	switch (comparator) {
	case XP_NE:
		return (value != test);
	case XP_LT:
		return (value < test);
	case XP_LE:
		return (value <= test);
	case XP_EQ:
		return (value == test);
	case XP_GE:
		return (value >= test);
	case XP_GT:
		return (value > test);
	}
	return (test == value);
}

// Returns the position of the next record that matches search criterion
item_num_t book::search(search_criteria_t* criteria, bool reset_search) {
	// Save the criteria
	criteria_ = criteria;
	item_num_t ix;
	if (reset_search) {
		ix = 0;
	}
	else {
		ix = last_search_result_ + 1;
	}
	for (; ix < size() && !match_record(get_record(ix, false)); ix++) {}
	if (ix < size()) {
		last_search_result_ = ix;
	}
	else {
		last_search_result_ = -1;
	}
	return last_search_result_;
}

// returns the current usage of the book
object_t book::book_type() { return book_type_; }

// Sets the book type
void book::book_type(object_t value) {
	book_type_ = value;
}

// Add the band and mode to the lists of used bands and modes if not already there
void book::add_use_data(record* use_record) {
	string band = use_record->item("BAND");
	if (band == "") {
		// Get the band from the frequency 
		double freq = 0.0;
		use_record->item("FREQ", freq);
		band = spec_data_->band_for_freq(freq);
		use_record->item("BAND", band);
	}
	if (band.length()) {
		used_bands_.insert(band);
	}
	string mode = use_record->item("MODE");
	if (mode.length()) {
		used_modes_.insert(mode);
	}
	string submode = use_record->item("SUBMODE");
	if (!submode.length()) {
		submode = use_record->item("MODE");
	}
	if (submode.length()) {
		used_submodes_.insert(submode);
	}
	string rig = use_record->item("MY_RIG");
	bool update_spec = false;
	if (rig.length()) {
		if (used_rigs_.find(rig) == used_rigs_.end()) {
			used_rigs_.insert(rig);
			spec_data_->add_user_enum("MY_RIG", rig);
			update_spec = true;
		}
	}
	string antenna = use_record->item("MY_ANTENNA");
	if (antenna.length()) {
		if (used_antennas_.find(antenna) == used_antennas_.end()) {
			used_antennas_.insert(antenna);
			spec_data_->add_user_enum("MY_ANTENNA", antenna);
			update_spec = true;
		}
	}
	string callsign = use_record->item("STATION_CALLSIGN");
	if (callsign.length()) {
		if (used_callsigns_.find(callsign) == used_callsigns_.end()) {
			used_callsigns_.insert(callsign);
			spec_data_->add_user_enum("STATION_CALLSIGN", callsign);
			update_spec = true;
		}
	}
	// "APP_ZZA_QTH" inplies a macro substitition. Description given in APP_ZZA_QTH_DESCR
	string qth = use_record->item("APP_ZZA_QTH");
	if (qth.length()) {
		macro_defn* qth_data;
		bool update_qth = false;
		if (used_qths_.find(qth) == used_qths_.end()) {
			qth_data = new macro_defn;
			qth_data->fields = new record;
			used_qths_[qth] = qth_data;
			update_qth = true;
		}
		else {
			qth_data = used_qths_.at(qth);
		}
		// Allow compiler to optimise this
		static const set<string> qth_fields = {
			"MY_NAME", "MY_STREET", "MY_CITY", "MY_POSTAL_CODE", "MY_GRIDSQUARE", "MY_COUNTRY",
			"MY_DXCC", "MY_STATE", "MY_CNTY", "MY_CQ_ZONE", "MY_ITU_ZONE", "MY_CONT", "MY_IOTA",
			"APP_ZZA_QTH_DESCR"
		};
		for (auto it = qth_fields.begin(); it != qth_fields.end(); it++) {
			string value = use_record->item(*it);
			// If it is in supplied data
			if (value.length()) {
				string old_value = qth_data->fields->item(*it);
				// and if it's already captured - check it is the same
				if (old_value.length() && old_value != value) {
					char message[128];
					if ((*it) == "MY_GRIDSQUARE" && value.length() < old_value.length() && value == old_value.substr(0, value.length())) {
						if (ignore_gridsquare_) {
							snprintf(message, 128, "LOG: QTH %s - Field %s=%s ignoring change to %s",
								qth.c_str(), (*it).c_str(), old_value.c_str(), value.c_str());
							status_->misc_status(ST_WARNING, message);
							ignore_gridsquare_ = true;
						}
						use_record->item((*it), old_value);
						modified(true);
					}
					else {
						snprintf(message, 128, "LOG: %s %s %s %s - new value  (%s) differs from old (%s)",
							use_record->item("QSO_DATE").c_str(),
							use_record->item("TIME_ON").c_str(),
							use_record->item("CALL").c_str(),
							(*it).c_str(),
							value.c_str(),
							old_value.c_str());
						status_->misc_status(ST_NOTE, message);
						if ((*it) != "MY_GRIDSQUARE" || value.length() > old_value.length() || value != old_value.substr(0, value.length())) {
							snprintf(message, 128, "LOG: QTH %s - Field %s replacing %s with %s",
								qth.c_str(), (*it).c_str(), old_value.c_str(), value.c_str());
							status_->misc_status(ST_WARNING, message);
							qth_data->fields->item(*it, value);
							update_qth = true;
						}
					}
				}
				else if (old_value.length() == 0) {
					qth_data->fields->item(*it, value);
					update_qth = true;
				}
			}
		}
		// description already forms part of qth_data no need to check it again
		if (update_qth) {
			// Update the spec data and then the spec ttree viewer
			qth_data->description = use_record->item("APP_ZZA_QTH_DESCR");
			spec_data_->add_user_macro("APP_ZZA_QTH", qth, *qth_data);
			update_spec = true;
		}
		if (update_spec && !main_loading_) {
			tabbed_forms_->update_views(nullptr, HT_FORMAT, size() - 1);
		}
	}
}

// get used bands
set<string>& book::used_bands() { return used_bands_; }

// get used modes
set<string>& book::used_modes() { return used_modes_; }

// get used submodes
set<string>& book::used_submodes() { return used_submodes_;  }

// Returns true if in incomplete new_record
bool book::modified_record() { return modified_record_; }

// Set entering record
void book::modified_record(bool value) { 
	modified_record_ = value;
}

// Returns true if a new record being entered
bool book::new_record() { return new_record_; }

// Set save_enabled_ (and save if modified)
void book::enable_save(bool enable) {
	if (enable) {
		if (save_level_) save_level_--;
	}
	else {
		save_level_++;
	}
	char msg[128];
	snprintf(msg, sizeof(msg), "LOG: Setting save enable level %d", save_level_);
	status_->misc_status(ST_LOG, msg);
#ifndef _DEBUG
	if (save_level_ == 0 && !read_only_) {
		store_data();
	}
#endif
}

// Check duplicates - restart set after a query to confirm it's a duplicate
void book::check_dupes(bool restart) {
	if (!restart) {
		duplicate_item_ = 0;
		// Only check N - 1 entries against the next entry
		status_->misc_status(ST_NOTE, "LOG: Duplicate checking started");
		status_->progress(size() - 1, book_type(), "Checking log for duplicates", "duplicates");
		inhibit_view_update_ = true;
		number_dupes_kept_ = 0;
		number_dupes_removed_ = 0;
	}
	bool possible_dupe = false;
	enable_save(false);
	for (; duplicate_item_ < size() - 1 && !possible_dupe;) {
		// Get adjacent records
		record* record_1 = get_record(duplicate_item_, true);
		record* record_2 = get_record(duplicate_item_ + 1, false);
		match_result_t match = record_1->match_records(record_2);
		switch (match) {
		case MT_NOMATCH:
		case MT_SWL_NOMATCH:
		case MT_SWL_MATCH:
			// Do nothing
			break;
		case MT_EXACT:
			// Delete second occurence after query
			match_question_ = "These appear to be duplicates - select one to delete";
			selection(duplicate_item_ + 1, HT_DUPE_QUERY, nullptr, duplicate_item_);
			possible_dupe = true;
			break;
		case MT_OVERLAP:
			if (record_1->item("CALL") != record_2->item("CALL")) {
				break;
			}
			// Else drop through
		default:
			// Open QSO query 
			match_question_ = "Possible duplicate record found";
			selection(duplicate_item_ + 1, HT_DUPE_QUERY, nullptr, duplicate_item_);
			possible_dupe = true;
			break;
		}
		duplicate_item_++;
		status_->progress(duplicate_item_, book_type());
	}
	if (!possible_dupe) {
		char message[256];
		snprintf(message, 256, "LOG: Dupe check complete. %d checked, %d kept, %d removed", duplicate_item_, number_dupes_kept_, number_dupes_removed_);
		status_->misc_status(ST_OK, message);
		inhibit_view_update_ = false;
		selection(size() - 1, HT_ALL);
	}
	enable_save(true);
}

// Handle duplicate action - KEEP_LOG or KEEP_DUPE - delete it
void book::reject_dupe(bool use_dupe) {
	if (use_dupe) {
		selection(duplicate_item_, HT_DUPE_DELETED);
	}
	else {
		selection(duplicate_item_ + 1, HT_DUPE_DELETED);
	}
	char message[128];
	snprintf(message, 128, "LOG: Duplicate record %s deleted", get_record()->item("CALL").c_str());
	status_->misc_status(ST_WARNING, message);
	delete_record(true);
	number_dupes_removed_++;
}

// Handle duplicate action - MERGE_DUPE - merge and delete it
void book::merge_dupe() {
	qso_num_t curr_record = record_number(duplicate_item_);
	qso_num_t dupe_record = record_number(duplicate_item_ + 1);
	get_record(duplicate_item_, false)->merge_records(get_record(duplicate_item_ + 1, false));
	selection(dupe_record, HT_DUPE_DELETED);
	char message[128];
	snprintf(message, 128, "LOG: Duplicate record %s merged && deleted", get_record(duplicate_item_ + 1, false)->item("CALL").c_str());
	status_->misc_status(ST_WARNING, message);
	delete_record(true);
	number_dupes_removed_++;
}

// Handle duplicate action - KEEP_BOTH - ignore and restart check
void book::accept_dupe() {
	char message[128];
	snprintf(message, 128, "LOG: Checked record %s not a duplicate", get_record(duplicate_item_ + 1, false)->item("CALL").c_str());
	status_->misc_status(ST_WARNING, message);
	number_dupes_kept_++;
	duplicate_item_++;
}

// Returns the reason record view has been activated - used by record view to prompt the user
string book::match_question() {
	return match_question_;
}

// Opens a text editor to allow the header comment to be edited
void book::edit_header() {
	status_->misc_status(ST_NOTE, "LOG: Editting header comment");
	// now read it into the text buffer
	Fl_Text_Buffer* buffer = new Fl_Text_Buffer;
	// Window to display the text editor and Save and Cancel buttons
	Fl_Window* win = new Fl_Window(640, 480);
	win->label("Header comment");

	// Text editor
	intl_editor* editor = new intl_editor(GAP, HBUTTON + 2 * GAP, 640 - 2 * GAP, 480 - 3 * GAP - HBUTTON);
	editor->buffer(buffer);
	editor->wrap_mode(Fl_Text_Display::WRAP_AT_BOUNDS, 0);
	editor->textfont(FL_COURIER);
	editor->textsize(12);

	// Save button
	Fl_Button* bn_save = new Fl_Button(GAP, GAP, WBUTTON, HBUTTON, "Save");
	bn_save->callback(cb_close_edith, (void*)this);
	// Cancel button
	Fl_Button* bn_cncl = new Fl_Button(GAP + WBUTTON + GAP, GAP, WBUTTON, HBUTTON, "Cancel");
	bn_cncl->callback(cb_cancel_edith, nullptr);
	// Default button
	Fl_Button* bn_default = new Fl_Button(GAP + WBUTTON + GAP + WBUTTON + GAP, GAP, WBUTTON, HBUTTON, "Default");
	bn_default->callback(cb_default_edith, nullptr);
	bn_default->tooltip(default_header_.c_str());
	// Restore button
	Fl_Button* bn_restore = new Fl_Button(bn_default->x() + bn_default->w() + GAP, GAP, WBUTTON, HBUTTON, "Restore");
	bn_restore->callback(cb_restore_edith, (void*)this);
	bn_restore->tooltip("Restore the original header");

	if (header_) {
		// Edit the header
		editor->buffer()->insert(0, header_->header().c_str());
	}
	else {
		// New header
		editor->buffer()->insert(0, default_header_.c_str());
	}
	// Allow editor to resize with window
	win->resizable(editor);
	// Close X button uses same callback as cancel
	win->callback(cb_cancel_edith, (void*)this);
	win->end();
	win->show();
	// Add the display to the main window to delete it if the main window is deleted first.
	//add_sub_window(win);
}

// Call back to restore default header
void book::cb_default_edith(Fl_Widget* w, void* v) {
	// Find the parent window of the widget (which may itself be the parent)
	Fl_Window* win = w->window();
	if (win == nullptr) win = (Fl_Window*)w;
	intl_editor* editor = nullptr;
	// Look at each child of the window until we find that is a text editor
	for (int i = 0; i < win->children() && editor == nullptr; i++) {
		editor = dynamic_cast<intl_editor*>(win->child(i));
	}
	// If we do find a text editor update the header from its current text
	if (editor) {
		editor->buffer()->remove(0, editor->buffer()->length());
		editor->buffer()->insert(0, default_header_.c_str());
	}
}

// Callback to retore original header value
void book::cb_restore_edith(Fl_Widget* w, void* v) {
	// Find the parent window of the widget (which may itself be the parent)
	Fl_Window* win = w->window();
	if (win == nullptr) win = (Fl_Window*)w;
	intl_editor* editor = nullptr;
	// Look at each child of the window until we find that is a text editor
	for (int i = 0; i < win->children() && editor == nullptr; i++) {
		editor = dynamic_cast<intl_editor*>(win->child(i));
	}
	// If we do find a text editor update the header from its current text
	if (editor) {
		book* that = (book*)v;
		editor->buffer()->remove(0, editor->buffer()->length());
		editor->buffer()->insert(0, that->header()->header().c_str());
	}
}

// Call back to save the new header value
void book::cb_close_edith(Fl_Widget* w, void* v) {
	// Find the parent window of the widget (which may itself be the parent)
	Fl_Window* win = w->window();
	if (win == nullptr) win = (Fl_Window*)w;
	intl_editor* editor = nullptr;
	// Look at each child of the window until we find that is a text editor
	for (int i = 0; i < win->children() && editor == nullptr; i++) {
		editor = dynamic_cast<intl_editor*>(win->child(i));
	}
	// If we do find a text editor update the header from its current text
	if (editor) {
		book* that = (book*)v;
		if (!that->header_) {
			that->header_ = new record();
		}
		that->header_->header(string(editor->buffer()->text()));
		that->modified(true);
	}
	menu_->enable(true);
	status_->misc_status(ST_OK, "LOG: Editting header comment - Done!");
	Fl_Window::default_callback(win, v);
}

// Call back to cancel the new header edit
void book::cb_cancel_edith(Fl_Widget* w, void* v) {
	// Find the parent window of the widget (which may itself be the parent)
	Fl_Window* win = w->window();
	if (win == nullptr) win = (Fl_Window*)w;
	status_->misc_status(ST_OK, "LOG: Editting header comment - Cancelled!");
	Fl_Window::default_callback(win, v);
}

// Return delete in progress - used to disable menu items
bool book::delete_enabled() {
	if (delete_in_progress_) {
		return false;
	}
	else {
		return true;
	}
}

// Upload the latest QSO imported to eQSL, LotW and Clublog
bool book::upload_qso(qso_num_t record_num) {
	enable_save(false);
	bool ok = eqsl_handler_->upload_single_qso(record_num);
	if (!lotw_handler_->upload_single_qso(record_num)) ok = false;
	if (!club_handler_->upload_single_qso(record_num)) ok = false;
	// Clear flag as already handled new record features
	new_record_ = false;
	enable_save(true);
	return ok;
}

// Return the been_modified_ flag
bool book::been_modified() {
	return been_modified_;
}

// return entrring new record
bool book::enterring_record() {
	return new_record_ || modified_record_;
}

// Find the most recent QSO that is the gap after the previous one and set that as session start
void book::set_session_start() {
#ifdef _DEBUG
	if (size()) session_start_ = get_record(size() - 1, false)->timestamp();
	else session_start_ = time(nullptr);
#else
	session_start_ = time(nullptr);
#endif
	Fl_Preferences user_settings(settings_, "User Settings");
	Fl_Preferences log_settings(user_settings, "Log Table");
	double session_gap_mins;
	log_settings.get("Session Gap", session_gap_mins, 30.0);
	if (size()) {
		// Start at end of book
		bool found = false;
		qso_num_t rec_num = size() - 1;
		while (rec_num > 0 && !found) {
			time_t qso_time = get_record(rec_num, false)->timestamp();
			if (difftime(session_start_, qso_time) < (session_gap_mins * 60.0)) {
				session_start_ = qso_time;
			}
			else {
				found = true;
			}
			rec_num--;
		}
	} 
	// Display the start time in the status log
	char stime[100];
	tm* start_time = gmtime(&session_start_);
	strftime(stime, 100, "%Y/%m/%d %H:%M:%S", start_time);
	char message[256];
	snprintf(message, 256, "ZZALOG: Setting session start at %s", stime);
	status_->misc_status(ST_NOTE, message);
}